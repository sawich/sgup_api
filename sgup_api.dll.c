/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
_DWORD *__thiscall sub_10001010(_DWORD *this, char a2);
bool __thiscall sub_10001040(void *this, int a2);
int sub_10001260();
int __stdcall sub_100012A0(int a1);
int __stdcall sub_100012E0(int a1);
int __stdcall sub_10001320(int a1);
int __stdcall sub_10001360(int a1);
int __stdcall sub_100013A0(int a1);
void __thiscall sub_100013E0(std::exception *this);
std::exception *__thiscall sub_100013F0(std::exception *this, char a2);
// int __usercall sub_10001420@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned __int8 *a3@<ecx>);
_DWORD *__thiscall sub_100014D0(_DWORD *this, char a2);
int __thiscall sub_10001500(_DWORD *this, int *a2);
int __thiscall sub_10001540(_DWORD *this, int a2);
void __thiscall sub_100015A0(_DWORD *this, char *a2, int a3);
void __thiscall sub_10001740(_DWORD *this, char *a2, int a3, int a4, __int16 a5);
// void __usercall sub_100018F0(int a1@<esi>);
// int __userpurge sub_10001920@<eax>(int a1@<esi>, int a2, size_t a3);
int __stdcall sub_10001950(void *Buf, int, int); // idb
// int __userpurge sub_100019F0@<eax>(int a1@<ecx>, size_t a2@<eax>, unsigned int a3@<ebx>, int a4);
// int __usercall sub_10001AD0@<eax>(_BYTE *a1@<eax>, size_t a2@<edi>, _DWORD *a3@<esi>);
// _DWORD *__usercall sub_10001BA0@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<esi>);
// BOOL __usercall sub_10001C20@<eax>(_DWORD *a1@<eax>, unsigned int a2@<esi>);
void __stdcall sub_10001C70(int a1, int a2, size_t Size);
void *__thiscall sub_10001DF0(void *this);
std::exception *__thiscall sub_10001E40(std::exception *this, const struct std::exception *a2);
int __thiscall sub_10001E60(_DWORD *this);
int __thiscall sub_10001E80(_DWORD *this, int a2);
int __thiscall sub_10001ED0(_DWORD *this, int a2, int a3);
int __thiscall sub_10001F20(_DWORD *this, int a2);
int __thiscall sub_10001F70(_DWORD *this, int a2, int a3);
int __thiscall sub_10002020(_DWORD *this);
int __thiscall sub_10002060(_DWORD *this, int a2);
int __thiscall sub_100020B0(_DWORD *this, int a2);
int __thiscall sub_10002100(_DWORD *this, int a2);
int __thiscall sub_10002150(_DWORD *this, int a2);
int __thiscall sub_100021A0(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_100021F0(_DWORD *this, int a2);
int __thiscall sub_10002240(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_10002290(_DWORD *this, int a2, int a3);
int __thiscall sub_100022E0(_DWORD *this, int a2, int a3);
int __thiscall sub_10002330(_DWORD *this, int a2, int a3);
int __thiscall sub_10002380(_DWORD *this, int a2, int a3);
_DWORD *__cdecl sub_10002400(__int64 a1);
int sub_10002480();
// bool __usercall sub_10002510@<al>(int a1@<esi>);
char __stdcall sub_100025F0(int a1);
int __thiscall sub_10002AB0(void ***this);
int __thiscall sub_10002B20(int this, __int16 a2);
void __stdcall sub_10002D00(int a1);
int __thiscall sub_10002DB0(_DWORD *this);
int __thiscall sub_10002DF0(_DWORD *this, __int64 a2, int a3, int a4, int a5);
int __thiscall sub_10002FE0(_DWORD *this, __int64 a2);
int __thiscall sub_10003180(_DWORD *this, __int64 a2);
int __thiscall sub_10003320(_DWORD *this, __int64 a2, bool *a3);
// int __userpurge sub_10003510@<eax>(char *a1@<eax>, _DWORD *a2);
_DWORD *__thiscall sub_10003550(_DWORD *this, _DWORD *a2);
int __thiscall sub_10003610(void ***this);
int __thiscall sub_100036C0(int this, int a2);
int __thiscall sub_10003890(int this, int a2);
int __thiscall sub_100038E0(int this);
unsigned int *__thiscall sub_10003950(int this, unsigned int *a2, __int64 a3, int a4, char a5);
unsigned int *__thiscall sub_10003B00(int this, unsigned int *a2, __int64 a3, int a4, int a5, int a6, int a7, char a8);
void ***__thiscall sub_10003C30(void ***this, char a2);
void ***__thiscall sub_10003CC0(void ***this, char a2);
// int __usercall sub_10003CF0@<eax>(_DWORD *a1@<edi>, int a2@<esi>);
// int __usercall sub_10003D60@<eax>(int a1@<ebx>);
// char *__usercall sub_10003DC0@<eax>(const char *a1@<eax>, size_t a2@<ebx>);
// _DWORD *__usercall sub_10003E80@<eax>(char a1@<bl>, _DWORD *a2@<esi>);
unsigned int __thiscall sub_10003F10(int *this, unsigned int a2);
// void __usercall sub_10004030(int a1@<eax>, int a2@<edi>);
// char *__userpurge sub_10004070@<eax>(unsigned int a1@<ebx>, int a2@<esi>, void *Src);
// _DWORD *__userpurge sub_10004150@<eax>(size_t a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3, unsigned int a4);
void *__fastcall sub_10004200(unsigned int a1);
// int __usercall sub_10004260@<eax>(const char *a1@<eax>, int a2@<ecx>);
// int __usercall sub_100042A0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
int __cdecl sub_100042E0(int a1);
_DWORD *__cdecl sub_10004450(int a1, void *a2);
char __thiscall sub_10004550(_DWORD *this);
int __thiscall sub_10004570(_DWORD *this);
int __thiscall sub_10004590(_DWORD *this);
int __thiscall sub_100045B0(_DWORD *this);
int __thiscall sub_100045D0(_DWORD *this);
__int64 __thiscall sub_100045F0(_DWORD *this);
int __cdecl sub_10004610(int, char *Source); // idb
char SGUPAPI_Init();
int SGUPAPI_Term();
void *__stdcall sub_10004FA0(void *a1);
int SGUPAPI_GetAuthToken();
int SGUPAPI_RenewAuthToken();
char *SGUPAPI_GetCurrentAccessToken();
int SGUPAPI_GetMessengerAuthToken();
int SGUPAPI_RenewMessengerAuthToken();
_DWORD *__cdecl SGUPAPI_SetCallback(int a1);
int SGUPAPI_RunCallback();
int SGUPUser();
int SGUPFriends();
int SGUPMatchMaking();
int SGUPPeerToPeer();
int SGUPOverlay();
// int __usercall sub_100052C0@<eax>(int a1@<esi>);
bool SGUPIAPI_MessengerInit();
int SGUPIAPI_MessengerTerm();
int SGUPIAPI_SendDuplicateLoginEvent();
int SGUPIAPI_GetMemberInfo();
int SGUPIAPI_InternalRenewAuthToken();
void __cdecl SGUPIAPI_SetCallback(int a1);
int __cdecl SGUPIAPI_SetCallbackSubscriptReq(int a1);
int __cdecl SGUPIAPI_SetCallbackMessengerConfigUpdate(int a1);
int __cdecl SGUPIAPI_SetCallbackGetMemberInfo(int a1);
int __cdecl SGUPIAPI_SetCallbackInternalRenewAuthToken(int a1);
int __cdecl SGUPIAPI_SetCallbackDuplicateLoginResult(int a1);
bool SGUPIAPI_OverlayHostInit();
int SGUPIAPI_OverlayHostTerm();
int SGUPIAPI_SetCallbackUpdateAuthToken();
// int __stdcall _CRT_INIT(int, void *Block, int); idb
// int __usercall __DllMainCRTStartup@<eax>(void *a1@<edx>, void *a2@<ecx>, HINSTANCE hinstDLL);
// BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
int sub_10005DE2();
void *sub_10005EA6();
// void __cdecl __security_init_cookie();
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// DWORD __stdcall SetNamedSecurityInfoA(LPSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// DWORD __stdcall GetLastError();
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// int std::streambuf::~streambuf<char,std::char_traits<char>>(void); weak
// int __thiscall std::streambuf::sgetc(_DWORD); weak
// int __thiscall std::streambuf::snextc(_DWORD); weak
// int __thiscall std::ios::~ios<char,std::char_traits<char>>(_DWORD); weak
// int __thiscall std::ios::setstate(_DWORD, _DWORD, _DWORD); weak
// void __cdecl std::_Xinvalid_argument(const char *); weak
// void __cdecl std::_Xout_of_range(const char *); weak
// int __cdecl Stoulx(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl __noreturn std::_Xlength_error(const char *); weak
// int __thiscall std::streambuf::streambuf(_DWORD); weak
// int __thiscall std::iostream::basic_iostream<char>(_DWORD, _DWORD, _DWORD); weak
// int __thiscall std::istream::_Ipfx(_DWORD, _DWORD); weak
// int __thiscall std::ios::ios(_DWORD); weak
// int __thiscall std::streambuf::_Pninc(_DWORD); weak
// int __thiscall std::streambuf::sbumpc(_DWORD); weak
// int __thiscall std::iostream::~basic_iostream<char,std::char_traits<char>>(_DWORD); weak
// errno_t __cdecl strncpy_s(char *Destination, rsize_t SizeInBytes, const char *Source, rsize_t MaxCount);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// wchar_t *__cdecl wcsncpy(wchar_t *Destination, const wchar_t *Source, size_t Count);
// int sprintf_s(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// void *__cdecl operator new(unsigned int); weak
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *); weak
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void __thiscall std::exception::~exception(std::exception *__hidden this); weak
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *); weak
// errno_t __cdecl wcscpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// errno_t __cdecl wcscat_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// void __cdecl operator delete(void *); weak

//-------------------------------------------------------------------------
// Data declarations

// extern const __int64 std::_BADOFF; weak
void *LauncherRelay::`vftable' = &sub_10001010; // weak
void *std::bad_alloc::`vftable' = &sub_100013F0; // weak
void *SG::P2P::CallBackHandler::`vftable' = &sub_100014D0; // weak
void *SGUPP2PCallbackHandler::`vftable' = &sub_100014D0; // weak
void *SGUPFriendsImpl::`vftable' = &sub_10001E60; // weak
void *SGUPMatchMakingImpl::`vftable' = &sub_10002020; // weak
void *std::stringbuf::`vftable' = &sub_10003CC0; // weak
void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable' = &sub_10003C30; // weak
_UNKNOWN unk_10007A38; // weak
_UNKNOWN unk_10007A40; // weak
void *SGUPPeerToPeerImpl::`vftable' = &sub_10002B20; // weak
void *SGUPUserImpl::`vftable' = &sub_10004550; // weak
_UNKNOWN unk_1000821C; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &sub_100013E0, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
wchar_t Source[] = L"\\Qt5Core.dll"; // idb
_UNKNOWN unk_1000B12C; // weak
int dword_1000B13C; // weak
int dword_1000B140; // weak
int dword_1000B144; // weak
int dword_1000B148; // weak
int dword_1000B14C; // weak
int dword_1000B150; // weak
int dword_1000B154; // weak
int dword_1000B158; // weak
int dword_1000B15C; // weak
char Destination[1024]; // idb
int dword_1000B560; // weak
int dword_1000B564; // weak
int (*SGUPLocalClient_SetCallbackUpdateAuthToken)(void); // weak
int dword_1000B56C; // weak
int (*SGUPLocalClient_OverlayHostTerm)(void); // weak
int dword_1000B574; // weak
int (*SGUPLocalClient_OverlayHostInit)(void); // weak
int dword_1000B57C; // weak
int (__cdecl *SGUPLocalClient_SetCallbackDuplicateLoginResult)(_DWORD); // weak
int dword_1000B584; // weak
int (__cdecl *SGUPLocalClient_SetCallbackInternalRenewAuthToken)(_DWORD); // weak
int dword_1000B58C; // weak
int (__cdecl *SGUPLocalClient_SetCallbackGetMemberInfo)(_DWORD); // weak
int dword_1000B594; // weak
int (__cdecl *SGUPLocalClient_SetCallbackMessengerConfigUpdate)(_DWORD); // weak
int dword_1000B59C; // weak
int (__cdecl *SGUPLocalClient_SetCallbackSubscriptReq)(_DWORD); // weak
int dword_1000B5A4; // weak
int (*SGUPLocalClient_InternalRenewAuthToken)(void); // weak
int dword_1000B5AC; // weak
int (*SGUPLocalClient_GetMemberInfo)(void); // weak
int dword_1000B5B4; // weak
int (*SGUPLocalClient_SendDuplicateLoginEvent)(void); // weak
int dword_1000B5BC; // weak
int (*SGUPLocalClient_MessengerTerm)(void); // weak
int dword_1000B5C4; // weak
int (*SGUPLocalClient_MessengerInit)(void); // weak
int dword_1000B5CC; // weak
int (*SGUPLocalClient_PostSystemMessage)(void); // weak
int dword_1000B5D4; // weak
int (__cdecl *SGUPLocalClient_StartGame)(_DWORD, _DWORD); // weak
int dword_1000B5DC; // weak
int (__cdecl *SGUPLocalClient_SetUserReady)(_DWORD, _DWORD); // weak
int dword_1000B5E4; // weak
int (__cdecl *SGUPLocalClient_DelLobbyData)(_DWORD, _DWORD); // weak
int dword_1000B5EC; // weak
int (__cdecl *SGUPLocalClient_GetLobbyData)(_DWORD, _DWORD); // weak
int dword_1000B5F4; // weak
int (__cdecl *SGUPLocalClient_SetLobbyData)(_DWORD, _DWORD, _DWORD); // weak
int dword_1000B5FC; // weak
int (__cdecl *SGUPLocalClient_GetGameServer)(_DWORD); // weak
int dword_1000B604; // weak
int (__cdecl *SGUPLocalClient_SetGameServer)(_DWORD, _DWORD, _DWORD); // weak
int dword_1000B60C; // weak
int (__cdecl *SGUPLocalClient_LeaveLobby)(_DWORD); // weak
int dword_1000B614; // weak
int (__cdecl *SGUPLocalClient_JoinLobby)(_DWORD); // weak
int dword_1000B61C; // weak
int (__cdecl *SGUPLocalClient_CreateLobby)(_DWORD); // weak
int dword_1000B624; // weak
int (__cdecl *SGUPLocalClient_RequestLobbyInfo)(_DWORD); // weak
int dword_1000B62C; // weak
int (*SGUPLocalClient_RequestLobbyList)(void); // weak
int dword_1000B634; // weak
int (__cdecl *SGUPLocalClient_SendChatMessage)(_DWORD, _DWORD); // weak
int dword_1000B63C; // weak
int (__cdecl *SGUPLocalClient_EndChat)(_DWORD); // weak
int dword_1000B644; // weak
int (__cdecl *SGUPLocalClient_StartOneOnOneChat)(_DWORD, _DWORD); // weak
int dword_1000B64C; // weak
int (__cdecl *SGUPLocalClient_GetFriendInfo)(_DWORD); // weak
int dword_1000B654; // weak
int (*SGUPLocalCleint_RenewMessengerAuthToken)(void); // weak
int dword_1000B65C; // weak
int (*SGUPLocalClient_GetMessengerAuthToken)(void); // weak
int dword_1000B664; // weak
int (*SGUPLocalClient_RenewAuthToken)(void); // weak
int dword_1000B66C; // weak
int (*SGUPLocalClient_GetAuthToken)(void); // weak
int dword_1000B674; // weak
int (__cdecl *SGUPLocalClient_SetOnRecvPacketFunc)(_DWORD); // weak
int dword_1000B67C; // weak
int (*SGUPLocalClient_RunCallback)(void); // weak
int dword_1000B684; // weak
int (*SGUPLocalClient_Term)(void); // weak
int dword_1000B68C; // weak
int (*SGUPLocalClient_Init)(void); // weak
int dword_1000B694; // weak


//----- (10001010) --------------------------------------------------------
_DWORD *__thiscall sub_10001010(_DWORD *this, char a2)
{
  *this = &LauncherRelay::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 10007830: using guessed type void *LauncherRelay::`vftable';

//----- (10001040) --------------------------------------------------------
bool __thiscall sub_10001040(void *this, int a2)
{
  LSTATUS v3; // eax
  const wchar_t *v5; // esi
  HMODULE v6; // eax
  DWORD Type; // [esp+4h] [ebp-62Ch] BYREF
  DWORD cbData; // [esp+8h] [ebp-628h] BYREF
  int v9; // [esp+Ch] [ebp-624h]
  HKEY phkResult; // [esp+10h] [ebp-620h] BYREF
  BYTE Data[2]; // [esp+14h] [ebp-61Ch] BYREF
  char v12[518]; // [esp+16h] [ebp-61Ah] BYREF
  wchar_t Destination; // [esp+21Ch] [ebp-414h] BYREF
  char v14[518]; // [esp+21Eh] [ebp-412h] BYREF
  wchar_t LibFileName; // [esp+424h] [ebp-20Ch] BYREF
  char v16[518]; // [esp+426h] [ebp-20Ah] BYREF

  v9 = a2;
  cbData = 260;
  *(_WORD *)Data = 0;
  memset(v12, 0, sizeof(v12));
  if ( this == (void *)2 )
  {
    v3 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SGUPQA\\ActiveProcess", 0, 0xF003Fu, &phkResult);
  }
  else if ( this == (void *)3 )
  {
    v3 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SGUPSANDBOX\\ActiveProcess", 0, 0xF003Fu, &phkResult);
  }
  else if ( this == (void *)4 )
  {
    v3 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SGUP\\ActiveProcess", 0, 0xF003Fu, &phkResult);
  }
  else if ( this == (void *)5 )
  {
    v3 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SGUPGATE8\\ActiveProcess", 0, 0xF003Fu, &phkResult);
  }
  else
  {
    v3 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SGUPDEV\\ActiveProcess", 0, 0xF003Fu, &phkResult);
  }
  if ( v3 || RegQueryValueExW(phkResult, L"WorkingDir", 0, &Type, Data, &cbData) )
    return 0;
  v5 = Source;
  while ( 1 )
  {
    Destination = 0;
    memset(v14, 0, sizeof(v14));
    wcscpy_s(&Destination, 0x104u, (const wchar_t *)Data);
    wcscat_s(&Destination, 0x104u, v5);
    if ( !LoadLibraryW(&Destination) )
      break;
    v5 += 260;
    if ( (int)v5 >= (int)L"\\sgup_local_control.dll" )
    {
      LibFileName = 0;
      memset(v16, 0, sizeof(v16));
      wcscpy_s(&LibFileName, 0x104u, (const wchar_t *)Data);
      wcscat_s(&LibFileName, 0x104u, L"\\sgup_local_control.dll");
      v6 = LoadLibraryW(&LibFileName);
      *(_DWORD *)(v9 + 4) = v6;
      return v6 != 0;
    }
  }
  return 0;
}
// 100071B0: using guessed type wchar_t aSoftwareSgupqa[30];
// 100071F0: using guessed type wchar_t aSoftwareSgupsa[35];
// 10007270: using guessed type wchar_t aSoftwareSgupga[33];

//----- (10001260) --------------------------------------------------------
int sub_10001260()
{
  HMODULE v0; // eax

  if ( (dword_1000B67C & 1) == 0 )
  {
    v0 = *(HMODULE *)(dword_1000B140 + 4);
    dword_1000B67C |= 1u;
    SGUPLocalClient_SetOnRecvPacketFunc = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                     v0,
                                                                     "SGUPLocalClient_SetOnRecvPacketFunc");
  }
  return SGUPLocalClient_SetOnRecvPacketFunc(sub_10004610);
}
// 1000B140: using guessed type int dword_1000B140;
// 1000B678: using guessed type int (__cdecl *SGUPLocalClient_SetOnRecvPacketFunc)(_DWORD);
// 1000B67C: using guessed type int dword_1000B67C;

//----- (100012A0) --------------------------------------------------------
int __stdcall sub_100012A0(int a1)
{
  HMODULE v1; // eax

  if ( (dword_1000B5A4 & 1) == 0 )
  {
    v1 = *(HMODULE *)(dword_1000B560 + 4);
    dword_1000B5A4 |= 1u;
    SGUPLocalClient_SetCallbackSubscriptReq = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                         v1,
                                                                         "SGUPLocalClient_SetCallbackSubscriptReq");
  }
  return SGUPLocalClient_SetCallbackSubscriptReq(a1);
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B5A0: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackSubscriptReq)(_DWORD);
// 1000B5A4: using guessed type int dword_1000B5A4;

//----- (100012E0) --------------------------------------------------------
int __stdcall sub_100012E0(int a1)
{
  HMODULE v1; // eax

  if ( (dword_1000B59C & 1) == 0 )
  {
    v1 = *(HMODULE *)(dword_1000B560 + 4);
    dword_1000B59C |= 1u;
    SGUPLocalClient_SetCallbackMessengerConfigUpdate = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                                  v1,
                                                                                  "SGUPLocalClient_SetCallbackMessengerConfigUpdate");
  }
  return SGUPLocalClient_SetCallbackMessengerConfigUpdate(a1);
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B598: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackMessengerConfigUpdate)(_DWORD);
// 1000B59C: using guessed type int dword_1000B59C;

//----- (10001320) --------------------------------------------------------
int __stdcall sub_10001320(int a1)
{
  HMODULE v1; // eax

  if ( (dword_1000B594 & 1) == 0 )
  {
    v1 = *(HMODULE *)(dword_1000B560 + 4);
    dword_1000B594 |= 1u;
    SGUPLocalClient_SetCallbackGetMemberInfo = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                          v1,
                                                                          "SGUPLocalClient_SetCallbackGetMemberInfo");
  }
  return SGUPLocalClient_SetCallbackGetMemberInfo(a1);
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B590: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackGetMemberInfo)(_DWORD);
// 1000B594: using guessed type int dword_1000B594;

//----- (10001360) --------------------------------------------------------
int __stdcall sub_10001360(int a1)
{
  HMODULE v1; // eax

  if ( (dword_1000B58C & 1) == 0 )
  {
    v1 = *(HMODULE *)(dword_1000B560 + 4);
    dword_1000B58C |= 1u;
    SGUPLocalClient_SetCallbackInternalRenewAuthToken = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                                   v1,
                                                                                   "SGUPLocalClient_SetCallbackInternalRenewAuthToken");
  }
  return SGUPLocalClient_SetCallbackInternalRenewAuthToken(a1);
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B588: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackInternalRenewAuthToken)(_DWORD);
// 1000B58C: using guessed type int dword_1000B58C;

//----- (100013A0) --------------------------------------------------------
int __stdcall sub_100013A0(int a1)
{
  HMODULE v1; // eax

  if ( (dword_1000B584 & 1) == 0 )
  {
    v1 = *(HMODULE *)(dword_1000B560 + 4);
    dword_1000B584 |= 1u;
    SGUPLocalClient_SetCallbackDuplicateLoginResult = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                                 v1,
                                                                                 "SGUPLocalClient_SetCallbackDuplicateLoginResult");
  }
  return SGUPLocalClient_SetCallbackDuplicateLoginResult(a1);
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B580: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackDuplicateLoginResult)(_DWORD);
// 1000B584: using guessed type int dword_1000B584;

//----- (100013E0) --------------------------------------------------------
void __thiscall sub_100013E0(std::exception *this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  std::exception::~exception(this);
}
// 1000713C: using guessed type void __thiscall std::exception::~exception(std::exception *__hidden this);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (100013F0) --------------------------------------------------------
std::exception *__thiscall sub_100013F0(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  std::exception::~exception(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1000713C: using guessed type void __thiscall std::exception::~exception(std::exception *__hidden this);
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (10001420) --------------------------------------------------------
int __usercall sub_10001420@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned __int8 *a3@<ecx>)
{
  unsigned int v3; // esi
  int v4; // eax

  v3 = a1;
  if ( a1 < 4 )
  {
LABEL_4:
    if ( !v3 )
      return 0;
  }
  else
  {
    while ( *(_DWORD *)a2 == *(_DWORD *)a3 )
    {
      v3 -= 4;
      a3 += 4;
      a2 += 4;
      if ( v3 < 4 )
        goto LABEL_4;
    }
  }
  v4 = *a2 - *a3;
  if ( v4 )
    return (v4 >> 31) | 1;
  if ( v3 <= 1 )
    return 0;
  v4 = a2[1] - a3[1];
  if ( v4 )
    return (v4 >> 31) | 1;
  if ( v3 <= 2 )
    return 0;
  v4 = a2[2] - a3[2];
  if ( v4 )
    return (v4 >> 31) | 1;
  if ( v3 > 3 )
  {
    v4 = a2[3] - a3[3];
    return (v4 >> 31) | 1;
  }
  return 0;
}

//----- (100014D0) --------------------------------------------------------
_DWORD *__thiscall sub_100014D0(_DWORD *this, char a2)
{
  *this = &SG::P2P::CallBackHandler::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 100078A4: using guessed type void *SG::P2P::CallBackHandler::`vftable';

//----- (10001500) --------------------------------------------------------
int __thiscall sub_10001500(_DWORD *this, int *a2)
{
  int result; // eax
  int (__thiscall ***v3)(_DWORD, int *); // ecx
  int v4[2]; // [esp+0h] [ebp-8h] BYREF

  if ( this[1] )
  {
    result = (int)a2;
    if ( a2 )
    {
      v3 = (int (__thiscall ***)(_DWORD, int *))this[1];
      v4[0] = *a2;
      v4[1] = 0;
      result = (**v3)(v3, v4);
    }
  }
  return result;
}

//----- (10001540) --------------------------------------------------------
int __thiscall sub_10001540(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // esi
  int (__thiscall ***v4)(_DWORD, int *); // ecx
  int v5[2]; // [esp+0h] [ebp-14h] BYREF
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]

  result = 0;
  if ( this[2] )
  {
    if ( a2 )
    {
      v5[0] = 0;
      v6 = 0;
      v7 = 0;
      v5[1] = 0;
      v3 = *(_DWORD *)a2;
      v4 = (int (__thiscall ***)(_DWORD, int *))this[2];
      v6 = *(unsigned __int8 *)(a2 + 32);
      v5[0] = v3;
      result = (**v4)(v4, v5);
    }
  }
  return result;
}

//----- (100015A0) --------------------------------------------------------
void __thiscall sub_100015A0(_DWORD *this, char *a2, int a3)
{
  int *v3; // eax
  size_t v4; // eax
  void **v5; // esi
  int v6; // eax
  void (__thiscall ***v7)(_DWORD, int *); // ecx
  void **v9; // [esp+14h] [ebp-74h] BYREF
  int v10; // [esp+18h] [ebp-70h] BYREF
  int v11; // [esp+1Ch] [ebp-6Ch]
  int v12; // [esp+20h] [ebp-68h] BYREF
  void *Buf[5]; // [esp+24h] [ebp-64h] BYREF
  unsigned int v14; // [esp+38h] [ebp-50h]
  void *v15[5]; // [esp+40h] [ebp-48h] BYREF
  unsigned int v16; // [esp+54h] [ebp-34h]
  int v17[4]; // [esp+5Ch] [ebp-2Ch] BYREF
  int v18; // [esp+6Ch] [ebp-1Ch]
  unsigned int v19; // [esp+70h] [ebp-18h]
  int v20; // [esp+84h] [ebp-4h]

  if ( this[3] && a2 )
  {
    v10 = 0;
    v11 = 0;
    v14 = 15;
    Buf[4] = 0;
    LOBYTE(Buf[0]) = 0;
    sub_10001AD0(a2, strlen(a2), Buf);
    v20 = 0;
    v19 = 15;
    v18 = 0;
    LOBYTE(v17[0]) = 0;
    sub_10001AD0("@", 1u, v17);
    LOBYTE(v20) = 1;
    v3 = (int *)v17[0];
    if ( v19 < 0x10 )
      v3 = v17;
    v4 = sub_10001950(Buf, (int)v3, v18);
    sub_10001920((int)v15, (int)Buf, v4);
    LOBYTE(v20) = 2;
    v5 = (void **)v15[0];
    if ( v16 < 0x10 )
      v5 = v15;
    v12 = 0;
    v6 = Stoulx(v5, &v9, 10, &v12);
    if ( v5 == v9 )
      std::_Xinvalid_argument("invalid stoul argument");
    if ( v12 )
      std::_Xout_of_range("stoul argument out of range");
    v10 = v6;
    v7 = (void (__thiscall ***)(_DWORD, int *))this[3];
    v11 = 0;
    (**v7)(v7, &v10);
    LOBYTE(v20) = 1;
    if ( v16 >= 0x10 )
      operator delete(v15[0]);
    LOBYTE(v20) = 0;
    v16 = 15;
    v15[4] = 0;
    LOBYTE(v15[0]) = 0;
    if ( v19 >= 0x10 )
      operator delete((void *)v17[0]);
    v20 = -1;
    v19 = 15;
    v18 = 0;
    LOBYTE(v17[0]) = 0;
    if ( v14 >= 0x10 )
      operator delete(Buf[0]);
  }
}
// 100016AB: variable 'v6' is possibly undefined
// 100070A4: using guessed type void __cdecl std::_Xinvalid_argument(const char *);
// 100070A8: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 100070AC: using guessed type int __cdecl Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10001740) --------------------------------------------------------
void __thiscall sub_10001740(_DWORD *this, char *a2, int a3, int a4, __int16 a5)
{
  int *v5; // eax
  size_t v6; // eax
  void **v7; // esi
  int v8; // eax
  void (__thiscall ***v9)(_DWORD, int *); // ecx
  void **v10; // [esp+10h] [ebp-84h] BYREF
  int v11; // [esp+14h] [ebp-80h]
  _DWORD *v12; // [esp+18h] [ebp-7Ch]
  int v13; // [esp+1Ch] [ebp-78h] BYREF
  int v14; // [esp+20h] [ebp-74h]
  int v15; // [esp+24h] [ebp-70h]
  int v16; // [esp+28h] [ebp-6Ch]
  int v17; // [esp+2Ch] [ebp-68h] BYREF
  void *Buf[5]; // [esp+30h] [ebp-64h] BYREF
  unsigned int v19; // [esp+44h] [ebp-50h]
  void *v20[5]; // [esp+4Ch] [ebp-48h] BYREF
  unsigned int v21; // [esp+60h] [ebp-34h]
  int v22[4]; // [esp+68h] [ebp-2Ch] BYREF
  int v23; // [esp+78h] [ebp-1Ch]
  unsigned int v24; // [esp+7Ch] [ebp-18h]
  int v25; // [esp+90h] [ebp-4h]

  v12 = this;
  v11 = a4;
  if ( this[4] )
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v19 = 15;
    Buf[4] = 0;
    LOBYTE(Buf[0]) = 0;
    sub_10001AD0(a2, strlen(a2), Buf);
    v25 = 0;
    v24 = 15;
    v23 = 0;
    LOBYTE(v22[0]) = 0;
    sub_10001AD0("@", 1u, v22);
    LOBYTE(v25) = 1;
    v5 = (int *)v22[0];
    if ( v24 < 0x10 )
      v5 = v22;
    v6 = sub_10001950(Buf, (int)v5, v23);
    sub_10001920((int)v20, (int)Buf, v6);
    LOBYTE(v25) = 2;
    v7 = (void **)v20[0];
    if ( v21 < 0x10 )
      v7 = v20;
    v17 = 0;
    v8 = Stoulx(v7, &v10, 10, &v17);
    if ( v7 == v10 )
      std::_Xinvalid_argument("invalid stoul argument");
    if ( v17 )
      std::_Xout_of_range("stoul argument out of range");
    v13 = v8;
    LOWORD(v16) = a5;
    v9 = (void (__thiscall ***)(_DWORD, int *))v12[4];
    v15 = v11;
    v14 = 0;
    (**v9)(v9, &v13);
    LOBYTE(v25) = 1;
    if ( v21 >= 0x10 )
      operator delete(v20[0]);
    LOBYTE(v25) = 0;
    v21 = 15;
    v20[4] = 0;
    LOBYTE(v20[0]) = 0;
    if ( v24 >= 0x10 )
      operator delete((void *)v22[0]);
    v25 = -1;
    v24 = 15;
    v23 = 0;
    LOBYTE(v22[0]) = 0;
    if ( v19 >= 0x10 )
      operator delete(Buf[0]);
  }
}
// 1000185A: variable 'v8' is possibly undefined
// 100070A4: using guessed type void __cdecl std::_Xinvalid_argument(const char *);
// 100070A8: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 100070AC: using guessed type int __cdecl Stoulx(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (100018F0) --------------------------------------------------------
void __usercall sub_100018F0(int a1@<esi>)
{
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
    operator delete(*(void **)a1);
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10001920) --------------------------------------------------------
int __userpurge sub_10001920@<eax>(int a1@<esi>, int a2, size_t a3)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_100019F0(a1, a3, 0, a2);
  return a1;
}

//----- (10001950) --------------------------------------------------------
int __stdcall sub_10001950(void *Buf, int a2, int a3)
{
  int result; // eax
  _BYTE *v4; // ebx
  unsigned int v5; // edi
  size_t v6; // edi
  unsigned __int8 *v7; // esi
  _BYTE *v8; // ecx

  result = a3;
  if ( a3 )
  {
    v4 = Buf;
    v5 = *((_DWORD *)Buf + 4);
    if ( !v5 || a3 > v5 )
      goto LABEL_9;
    v6 = 1 - a3 + v5;
    if ( *((_DWORD *)Buf + 5) >= 0x10u )
      v4 = *(_BYTE **)Buf;
    v7 = (unsigned __int8 *)memchr(v4, *(char *)a2, v6);
    if ( v7 )
    {
      while ( sub_10001420(a3, v7, (unsigned __int8 *)a2) )
      {
        v6 = v6 + v4 - v7 - 1;
        v4 = v7 + 1;
        v7 = (unsigned __int8 *)memchr(v7 + 1, *(char *)a2, v6);
        if ( !v7 )
          goto LABEL_9;
      }
      v8 = Buf;
      if ( *((_DWORD *)Buf + 5) >= 0x10u )
        v8 = *(_BYTE **)Buf;
      result = v7 - v8;
    }
    else
    {
LABEL_9:
      result = -1;
    }
  }
  return result;
}

//----- (100019F0) --------------------------------------------------------
int __userpurge sub_100019F0@<eax>(int a1@<ecx>, size_t a2@<eax>, unsigned int a3@<ebx>, int a4)
{
  _DWORD *v5; // ecx
  unsigned int v6; // edi
  size_t v7; // edi
  int result; // eax
  unsigned int v9; // eax
  void *v10; // eax
  bool v11; // cf

  v5 = (_DWORD *)a4;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = v6 - a3;
  if ( a2 < v7 )
    v7 = a2;
  if ( (_DWORD *)a1 == v5 )
  {
    sub_10001BA0(0xFFFFFFFF, v7 + a3, (_DWORD *)a1);
    sub_10001BA0(a3, 0, (_DWORD *)a1);
    return a1;
  }
  if ( v7 == -1 )
    std::_Xlength_error("string too long");
  v9 = *(_DWORD *)(a1 + 20);
  if ( v9 < v7 )
  {
    sub_10001C70(a1, v7, *(_DWORD *)(a1 + 16));
    v5 = (_DWORD *)a4;
    if ( !v7 )
      return a1;
LABEL_11:
    if ( v5[5] >= 0x10u )
      v5 = (_DWORD *)*v5;
    if ( *(_DWORD *)(a1 + 20) < 0x10u )
      v10 = (void *)a1;
    else
      v10 = *(void **)a1;
    memcpy(v10, (char *)v5 + a3, v7);
    v11 = *(_DWORD *)(a1 + 20) < 0x10u;
    *(_DWORD *)(a1 + 16) = v7;
    if ( !v11 )
    {
      *(_BYTE *)(*(_DWORD *)a1 + v7) = 0;
      return a1;
    }
    *(_BYTE *)(a1 + v7) = 0;
    return a1;
  }
  if ( v7 )
    goto LABEL_11;
  *(_DWORD *)(a1 + 16) = 0;
  if ( v9 < 0x10 )
  {
    result = a1;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    **(_BYTE **)a1 = 0;
    result = a1;
  }
  return result;
}
// 10001A10: variable 'a2' is possibly undefined
// 10001A16: variable 'v5' is possibly undefined
// 100070A8: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (10001AD0) --------------------------------------------------------
int __usercall sub_10001AD0@<eax>(_BYTE *a1@<eax>, size_t a2@<edi>, _DWORD *a3@<esi>)
{
  unsigned int v4; // ecx
  unsigned int v5; // eax
  int v6; // eax
  int result; // eax
  unsigned int v8; // eax
  void *v9; // eax
  bool v10; // cf

  if ( a1 )
  {
    v4 = a3[5];
    v5 = (unsigned int)(v4 < 0x10 ? a3 : *a3);
    if ( (unsigned int)a1 >= v5 )
    {
      v6 = (int)(v4 < 0x10 ? a3 : *a3);
      if ( v6 + a3[4] > (unsigned int)a1 )
      {
        if ( v4 < 0x10 )
          result = sub_100019F0((int)a3, a2, a1 - (_BYTE *)a3, (int)a3);
        else
          result = sub_100019F0((int)a3, a2, (unsigned int)&a1[-*a3], (int)a3);
        return result;
      }
    }
  }
  if ( a2 == -1 )
    std::_Xlength_error("string too long");
  v8 = a3[5];
  if ( v8 < a2 )
  {
    sub_10001C70((int)a3, a2, a3[4]);
    if ( !a2 )
      return (int)a3;
LABEL_17:
    if ( a3[5] < 0x10u )
      v9 = a3;
    else
      v9 = (void *)*a3;
    memcpy(v9, a1, a2);
    v10 = a3[5] < 0x10u;
    a3[4] = a2;
    if ( !v10 )
    {
      *(_BYTE *)(*a3 + a2) = 0;
      return (int)a3;
    }
    *((_BYTE *)a3 + a2) = 0;
    return (int)a3;
  }
  if ( a2 )
    goto LABEL_17;
  a3[4] = 0;
  if ( v8 < 0x10 )
  {
    result = (int)a3;
    *(_BYTE *)a3 = 0;
  }
  else
  {
    *(_BYTE *)*a3 = 0;
    result = (int)a3;
  }
  return result;
}
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (10001BA0) --------------------------------------------------------
_DWORD *__usercall sub_10001BA0@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<esi>)
{
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  _DWORD *v7; // ebx
  _DWORD *v8; // edx
  unsigned int v9; // eax
  bool v10; // cf

  v4 = a3[4];
  if ( v4 < a2 )
    std::_Xout_of_range("invalid string position");
  v5 = v4 - a2;
  if ( v5 < a1 )
    a1 = v5;
  if ( a1 )
  {
    v6 = a3[5];
    if ( v6 < 0x10 )
      v7 = a3;
    else
      v7 = (_DWORD *)*a3;
    if ( v6 < 0x10 )
      v8 = a3;
    else
      v8 = (_DWORD *)*a3;
    memmove((char *)v8 + a2, (char *)v7 + a2 + a1, v5 - a1);
    v9 = a3[4] - a1;
    v10 = a3[5] < 0x10u;
    a3[4] = v9;
    if ( !v10 )
    {
      *(_BYTE *)(*a3 + v9) = 0;
      return a3;
    }
    *((_BYTE *)a3 + v9) = 0;
  }
  return a3;
}
// 10001BB5: variable 'v4' is possibly undefined
// 10001BB5: variable 'a2' is possibly undefined
// 100070A8: using guessed type void __cdecl std::_Xout_of_range(const char *);

//----- (10001C20) --------------------------------------------------------
BOOL __usercall sub_10001C20@<eax>(_DWORD *a1@<eax>, unsigned int a2@<esi>)
{
  unsigned int v2; // ecx
  BOOL result; // eax

  if ( a2 == -1 )
    std::_Xlength_error("string too long");
  v2 = a1[5];
  if ( v2 >= a2 )
  {
    if ( !a2 )
    {
      a1[4] = 0;
      if ( v2 >= 0x10 )
        a1 = (_DWORD *)*a1;
      *(_BYTE *)a1 = 0;
    }
    result = a2 != 0;
  }
  else
  {
    sub_10001C70((int)a1, a2, a1[4]);
    result = a2 != 0;
  }
  return result;
}
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (10001C70) --------------------------------------------------------
void __stdcall sub_10001C70(int a1, int a2, size_t Size)
{
  int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  void *v7; // eax
  void *v8; // ebx
  size_t v9; // ecx
  const void *v10; // eax
  int v11; // [esp+0h] [ebp-34h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-24h] BYREF
  const char *v13[2]; // [esp+20h] [ebp-14h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  v13[1] = (const char *)&v11;
  v3 = a1;
  v4 = a2 | 0xF;
  if ( (a2 | 0xF) == -1 )
  {
    v4 = a2;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 20);
    v6 = v5 >> 1;
    if ( v5 >> 1 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > -2 - v6 )
        v4 = -2;
    }
  }
  v7 = 0;
  v14 = 0;
  if ( v4 != -1 )
  {
    v7 = operator new(v4 + 1);
    if ( !v7 )
    {
      v13[0] = 0;
      std::exception::exception((std::exception *)pExceptionObject, v13);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  v8 = v7;
  v14 = -1;
  v9 = Size;
  if ( Size )
  {
    if ( *(_DWORD *)(a1 + 20) < 0x10u )
      v10 = (const void *)a1;
    else
      v10 = *(const void **)a1;
    memcpy(v8, v10, Size);
    v9 = Size;
  }
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
  {
    operator delete(*(void **)a1);
    v9 = Size;
  }
  *(_BYTE *)a1 = 0;
  *(_DWORD *)a1 = v8;
  *(_DWORD *)(a1 + 20) = v4;
  *(_DWORD *)(a1 + 16) = v9;
  if ( v4 >= 0x10 )
    v3 = (int)v8;
  *(_BYTE *)(v3 + v9) = 0;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007140: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (10001DF0) --------------------------------------------------------
void *__thiscall sub_10001DF0(void *this)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  const char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( this )
  {
    result = operator new((unsigned int)this);
    if ( !result )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, &v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007140: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (10001E40) --------------------------------------------------------
std::exception *__thiscall sub_10001E40(std::exception *this, const struct std::exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 10007130: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (10001E60) --------------------------------------------------------
int __thiscall sub_10001E60(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[2];
  if ( v1 )
    result = *(_DWORD *)(*(_DWORD *)(v1 + 268) + 1288);
  else
    result = 0;
  return result;
}

//----- (10001E80) --------------------------------------------------------
int __thiscall sub_10001E80(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B654 & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B654 |= 1u;
      SGUPLocalClient_GetFriendInfo = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_GetFriendInfo");
    }
    result = SGUPLocalClient_GetFriendInfo(a2);
  }
  return result;
}
// 1000B650: using guessed type int (__cdecl *SGUPLocalClient_GetFriendInfo)(_DWORD);
// 1000B654: using guessed type int dword_1000B654;

//----- (10001ED0) --------------------------------------------------------
int __thiscall sub_10001ED0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  HMODULE v4; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B64C & 1) == 0 )
    {
      v4 = *(HMODULE *)(result + 4);
      dword_1000B64C |= 1u;
      SGUPLocalClient_StartOneOnOneChat = (int (__cdecl *)(_DWORD, _DWORD))GetProcAddress(
                                                                             v4,
                                                                             "SGUPLocalClient_StartOneOnOneChat");
    }
    result = SGUPLocalClient_StartOneOnOneChat(a2, a3);
  }
  return result;
}
// 1000B648: using guessed type int (__cdecl *SGUPLocalClient_StartOneOnOneChat)(_DWORD, _DWORD);
// 1000B64C: using guessed type int dword_1000B64C;

//----- (10001F20) --------------------------------------------------------
int __thiscall sub_10001F20(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B644 & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B644 |= 1u;
      SGUPLocalClient_EndChat = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_EndChat");
    }
    result = SGUPLocalClient_EndChat(a2);
  }
  return result;
}
// 1000B640: using guessed type int (__cdecl *SGUPLocalClient_EndChat)(_DWORD);
// 1000B644: using guessed type int dword_1000B644;

//----- (10001F70) --------------------------------------------------------
int __thiscall sub_10001F70(_DWORD *this, int a2, int a3)
{
  int result; // eax
  HMODULE v4; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B63C & 1) == 0 )
    {
      v4 = *(HMODULE *)(result + 4);
      dword_1000B63C |= 1u;
      SGUPLocalClient_SendChatMessage = (int (__cdecl *)(_DWORD, _DWORD))GetProcAddress(
                                                                           v4,
                                                                           "SGUPLocalClient_SendChatMessage");
    }
    result = SGUPLocalClient_SendChatMessage(a2, a3);
  }
  return result;
}
// 1000B638: using guessed type int (__cdecl *SGUPLocalClient_SendChatMessage)(_DWORD, _DWORD);
// 1000B63C: using guessed type int dword_1000B63C;

//----- (10002020) --------------------------------------------------------
int __thiscall sub_10002020(_DWORD *this)
{
  int result; // eax
  HMODULE v2; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B634 & 1) == 0 )
    {
      v2 = *(HMODULE *)(result + 4);
      dword_1000B634 |= 1u;
      SGUPLocalClient_RequestLobbyList = GetProcAddress(v2, "SGUPLocalClient_RequestLobbyList");
    }
    result = SGUPLocalClient_RequestLobbyList();
  }
  return result;
}
// 1000B630: using guessed type int (*SGUPLocalClient_RequestLobbyList)(void);
// 1000B634: using guessed type int dword_1000B634;

//----- (10002060) --------------------------------------------------------
int __thiscall sub_10002060(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B62C & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B62C |= 1u;
      SGUPLocalClient_RequestLobbyInfo = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_RequestLobbyInfo");
    }
    result = SGUPLocalClient_RequestLobbyInfo(a2);
  }
  return result;
}
// 1000B628: using guessed type int (__cdecl *SGUPLocalClient_RequestLobbyInfo)(_DWORD);
// 1000B62C: using guessed type int dword_1000B62C;

//----- (100020B0) --------------------------------------------------------
int __thiscall sub_100020B0(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B624 & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B624 |= 1u;
      SGUPLocalClient_CreateLobby = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_CreateLobby");
    }
    result = SGUPLocalClient_CreateLobby(a2);
  }
  return result;
}
// 1000B620: using guessed type int (__cdecl *SGUPLocalClient_CreateLobby)(_DWORD);
// 1000B624: using guessed type int dword_1000B624;

//----- (10002100) --------------------------------------------------------
int __thiscall sub_10002100(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B61C & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B61C |= 1u;
      SGUPLocalClient_JoinLobby = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_JoinLobby");
    }
    result = SGUPLocalClient_JoinLobby(a2);
  }
  return result;
}
// 1000B618: using guessed type int (__cdecl *SGUPLocalClient_JoinLobby)(_DWORD);
// 1000B61C: using guessed type int dword_1000B61C;

//----- (10002150) --------------------------------------------------------
int __thiscall sub_10002150(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B614 & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B614 |= 1u;
      SGUPLocalClient_LeaveLobby = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_LeaveLobby");
    }
    result = SGUPLocalClient_LeaveLobby(a2);
  }
  return result;
}
// 1000B610: using guessed type int (__cdecl *SGUPLocalClient_LeaveLobby)(_DWORD);
// 1000B614: using guessed type int dword_1000B614;

//----- (100021A0) --------------------------------------------------------
int __thiscall sub_100021A0(_DWORD *this, int a2, int a3, int a4)
{
  int result; // eax
  HMODULE v5; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B60C & 1) == 0 )
    {
      v5 = *(HMODULE *)(result + 4);
      dword_1000B60C |= 1u;
      SGUPLocalClient_SetGameServer = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                 v5,
                                                                                 "SGUPLocalClient_SetGameServer");
    }
    result = SGUPLocalClient_SetGameServer(a2, a3, a4);
  }
  return result;
}
// 1000B608: using guessed type int (__cdecl *SGUPLocalClient_SetGameServer)(_DWORD, _DWORD, _DWORD);
// 1000B60C: using guessed type int dword_1000B60C;

//----- (100021F0) --------------------------------------------------------
int __thiscall sub_100021F0(_DWORD *this, int a2)
{
  int result; // eax
  HMODULE v3; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B604 & 1) == 0 )
    {
      v3 = *(HMODULE *)(result + 4);
      dword_1000B604 |= 1u;
      SGUPLocalClient_GetGameServer = (int (__cdecl *)(_DWORD))GetProcAddress(v3, "SGUPLocalClient_GetGameServer");
    }
    result = SGUPLocalClient_GetGameServer(a2);
  }
  return result;
}
// 1000B600: using guessed type int (__cdecl *SGUPLocalClient_GetGameServer)(_DWORD);
// 1000B604: using guessed type int dword_1000B604;

//----- (10002240) --------------------------------------------------------
int __thiscall sub_10002240(_DWORD *this, int a2, int a3, int a4)
{
  int result; // eax
  HMODULE v5; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B5FC & 1) == 0 )
    {
      v5 = *(HMODULE *)(result + 4);
      dword_1000B5FC |= 1u;
      SGUPLocalClient_SetLobbyData = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                v5,
                                                                                "SGUPLocalClient_SetLobbyData");
    }
    result = SGUPLocalClient_SetLobbyData(a2, a3, a4);
  }
  return result;
}
// 1000B5F8: using guessed type int (__cdecl *SGUPLocalClient_SetLobbyData)(_DWORD, _DWORD, _DWORD);
// 1000B5FC: using guessed type int dword_1000B5FC;

//----- (10002290) --------------------------------------------------------
int __thiscall sub_10002290(_DWORD *this, int a2, int a3)
{
  int result; // eax
  HMODULE v4; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B5F4 & 1) == 0 )
    {
      v4 = *(HMODULE *)(result + 4);
      dword_1000B5F4 |= 1u;
      SGUPLocalClient_GetLobbyData = (int (__cdecl *)(_DWORD, _DWORD))GetProcAddress(v4, "SGUPLocalClient_GetLobbyData");
    }
    result = SGUPLocalClient_GetLobbyData(a2, a3);
  }
  return result;
}
// 1000B5F0: using guessed type int (__cdecl *SGUPLocalClient_GetLobbyData)(_DWORD, _DWORD);
// 1000B5F4: using guessed type int dword_1000B5F4;

//----- (100022E0) --------------------------------------------------------
int __thiscall sub_100022E0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  HMODULE v4; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B5EC & 1) == 0 )
    {
      v4 = *(HMODULE *)(result + 4);
      dword_1000B5EC |= 1u;
      SGUPLocalClient_DelLobbyData = (int (__cdecl *)(_DWORD, _DWORD))GetProcAddress(v4, "SGUPLocalClient_DelLobbyData");
    }
    result = SGUPLocalClient_DelLobbyData(a2, a3);
  }
  return result;
}
// 1000B5E8: using guessed type int (__cdecl *SGUPLocalClient_DelLobbyData)(_DWORD, _DWORD);
// 1000B5EC: using guessed type int dword_1000B5EC;

//----- (10002330) --------------------------------------------------------
int __thiscall sub_10002330(_DWORD *this, int a2, int a3)
{
  int result; // eax
  HMODULE v4; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B5E4 & 1) == 0 )
    {
      v4 = *(HMODULE *)(result + 4);
      dword_1000B5E4 |= 1u;
      SGUPLocalClient_SetUserReady = (int (__cdecl *)(_DWORD, _DWORD))GetProcAddress(v4, "SGUPLocalClient_SetUserReady");
    }
    result = SGUPLocalClient_SetUserReady(a2, a3);
  }
  return result;
}
// 1000B5E0: using guessed type int (__cdecl *SGUPLocalClient_SetUserReady)(_DWORD, _DWORD);
// 1000B5E4: using guessed type int dword_1000B5E4;

//----- (10002380) --------------------------------------------------------
int __thiscall sub_10002380(_DWORD *this, int a2, int a3)
{
  int result; // eax
  HMODULE v4; // eax

  result = this[1];
  if ( result )
  {
    if ( (dword_1000B5DC & 1) == 0 )
    {
      v4 = *(HMODULE *)(result + 4);
      dword_1000B5DC |= 1u;
      SGUPLocalClient_StartGame = (int (__cdecl *)(_DWORD, _DWORD))GetProcAddress(v4, "SGUPLocalClient_StartGame");
    }
    result = SGUPLocalClient_StartGame(a2, a3);
  }
  return result;
}
// 1000B5D8: using guessed type int (__cdecl *SGUPLocalClient_StartGame)(_DWORD, _DWORD);
// 1000B5DC: using guessed type int dword_1000B5DC;

//----- (10002400) --------------------------------------------------------
_DWORD *__cdecl sub_10002400(__int64 a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  char Buffer[68]; // [esp+10h] [ebp-48h] BYREF

  v2 = v1;
  sprintf_s(Buffer, 0x40u, "%I64u", a1);
  v2[5] = 15;
  v2[4] = 0;
  *(_BYTE *)v2 = 0;
  sub_10001AD0(Buffer, strlen(Buffer), v2);
  return v2;
}
// 10002416: variable 'v1' is possibly undefined

//----- (10002480) --------------------------------------------------------
int sub_10002480()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B13C;
  if ( dword_1000B13C )
  {
    if ( (dword_1000B5D4 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B13C + 4);
      dword_1000B5D4 |= 1u;
      SGUPLocalClient_PostSystemMessage = GetProcAddress(v1, "SGUPLocalClient_PostSystemMessage");
    }
    result = SGUPLocalClient_PostSystemMessage();
  }
  return result;
}
// 1000B13C: using guessed type int dword_1000B13C;
// 1000B5D0: using guessed type int (*SGUPLocalClient_PostSystemMessage)(void);
// 1000B5D4: using guessed type int dword_1000B5D4;

//----- (10002510) --------------------------------------------------------
bool __usercall sub_10002510@<al>(int a1@<esi>)
{
  HMODULE v2; // eax
  DWORD Type; // [esp+0h] [ebp-218h] BYREF
  DWORD cbData; // [esp+4h] [ebp-214h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-210h] BYREF
  BYTE Data[2]; // [esp+Ch] [ebp-20Ch] BYREF
  char v7[518]; // [esp+Eh] [ebp-20Ah] BYREF

  cbData = 260;
  *(_WORD *)Data = 0;
  memset(v7, 0, sizeof(v7));
  if ( RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SGUP\\ActiveProcess", 0, 0xF003Fu, &phkResult)
    || RegQueryValueExW(phkResult, L"WorkingDir", 0, &Type, Data, &cbData) )
  {
    return 0;
  }
  wcscat_s((wchar_t *)Data, 0x104u, L"\\SGP2PLib.dll");
  v2 = LoadLibraryW((LPCWSTR)Data);
  *(_DWORD *)(a1 + 4) = v2;
  return v2 != 0;
}

//----- (100025F0) --------------------------------------------------------
char __stdcall sub_100025F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char *v3; // eax
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v6; // eax
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // eax
  void **v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  unsigned int v15; // eax
  int v16; // eax
  unsigned int v17; // [esp+18h] [ebp-10Ch] BYREF
  unsigned int v18; // [esp+1Ch] [ebp-108h]
  int v19; // [esp+20h] [ebp-104h]
  int v20; // [esp+28h] [ebp-FCh]
  int v21[6]; // [esp+2Ch] [ebp-F8h] BYREF
  void **v22[18]; // [esp+44h] [ebp-E0h] BYREF
  char v23[76]; // [esp+8Ch] [ebp-98h] BYREF
  void *v24[4]; // [esp+D8h] [ebp-4Ch] BYREF
  int v25; // [esp+E8h] [ebp-3Ch]
  unsigned int v26; // [esp+ECh] [ebp-38h]
  void *v27[5]; // [esp+F4h] [ebp-30h] BYREF
  unsigned int v28; // [esp+108h] [ebp-1Ch]
  int v29; // [esp+120h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 24);
  v2 = 0;
  if ( !v1 )
    return 0;
  v3 = (char *)(*(_DWORD *)(v1 + 268) + 257);
  v28 = 15;
  v27[4] = 0;
  LOBYTE(v27[0]) = 0;
  sub_10001AD0(v3, strlen(v3), v27);
  v29 = 2;
  v26 = 15;
  v25 = 0;
  LOBYTE(v24[0]) = 0;
  v4 = 0;
  v5 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  sub_10003550(v27, v21);
  LOBYTE(v29) = 3;
  v6 = sub_100042E0((int)v21);
  if ( ((*(_DWORD *)(v6 + *(_DWORD *)(*(_DWORD *)v6 + 4) + 12) & 6) == 0 ? v6 + *(_DWORD *)(*(_DWORD *)v6 + 4) : 0) != 0 )
  {
    while ( 1 )
    {
      if ( (unsigned int)v24 >= v5 || v4 > (unsigned int)v24 )
      {
        if ( v5 == v2 )
        {
          if ( (unsigned int)((int)(v5 - v4) / 28) > 0x9249248 )
LABEL_38:
            std::_Xlength_error("vector<T> too long");
          v13 = (int)(v5 - v4) / 28 + 1;
          v14 = (int)(v2 - v4) / 28;
          if ( v13 > v14 )
          {
            if ( 153391689 - (v14 >> 1) >= v14 )
              v15 = (v14 >> 1) + v14;
            else
              v15 = 0;
            if ( v15 < v13 )
              v15 = (int)(v5 - v4) / 28 + 1;
            sub_10003F10((int *)&v17, v15);
            v5 = v18;
            v4 = v17;
          }
        }
        LOBYTE(v29) = 5;
        if ( v5 )
        {
          v12 = v24;
LABEL_35:
          *(_DWORD *)(v5 + 20) = 15;
          *(_DWORD *)(v5 + 16) = 0;
          *(_BYTE *)v5 = 0;
          sub_100019F0(v5, 0xFFFFFFFF, 0, (int)v12);
          goto LABEL_36;
        }
      }
      else
      {
        v8 = (int)((int)v24 - v4) / 28;
        v20 = v8;
        if ( v5 == v2 )
        {
          if ( (unsigned int)((int)(v5 - v4) / 28) > 0x9249248 )
            goto LABEL_38;
          v9 = (int)(v5 - v4) / 28 + 1;
          v10 = (int)(v2 - v4) / 28;
          if ( v9 > v10 )
          {
            if ( 153391689 - (v10 >> 1) >= v10 )
              v11 = (v10 >> 1) + v10;
            else
              v11 = 0;
            if ( v11 < v9 )
              v11 = (int)(v5 - v4) / 28 + 1;
            sub_10003F10((int *)&v17, v11);
            v5 = v18;
            v4 = v17;
          }
          v8 = v20;
        }
        v12 = (void **)(v4 + 28 * v8);
        LOBYTE(v29) = 4;
        if ( v5 )
          goto LABEL_35;
      }
LABEL_36:
      LOBYTE(v29) = 3;
      v5 += 28;
      v18 = v5;
      v16 = sub_100042E0((int)v21);
      if ( ((*(_DWORD *)(v16 + *(_DWORD *)(*(_DWORD *)v16 + 4) + 12) & 6) == 0 ? v16 + *(_DWORD *)(*(_DWORD *)v16 + 4) : 0) == 0 )
        break;
      v2 = v19;
    }
  }
  if ( (unsigned int)((int)(v5 - v4) / 28) < 2 )
  {
    *(int *)((char *)v21 + *(_DWORD *)(v21[0] + 4)) = (int)&std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
    LOBYTE(v29) = 6;
    sub_10003610(v22);
    LOBYTE(v29) = 2;
    std::iostream::~basic_iostream<char,std::char_traits<char>>(v22);
    std::ios::~ios<char,std::char_traits<char>>(v23);
    LOBYTE(v29) = 1;
    sub_10003D60((int)&v17);
    LOBYTE(v29) = 0;
    if ( v26 >= 0x10 )
      operator delete(v24[0]);
    v29 = -1;
    v26 = 15;
    v25 = 0;
    LOBYTE(v24[0]) = 0;
    if ( v28 >= 0x10 )
      operator delete(v27[0]);
    return 0;
  }
  sub_100019F0(a1 + 28, 0xFFFFFFFF, 0, v4 + 28);
  *(int *)((char *)v21 + *(_DWORD *)(v21[0] + 4)) = (int)&std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  LOBYTE(v29) = 7;
  sub_10003610(v22);
  LOBYTE(v29) = 2;
  std::iostream::~basic_iostream<char,std::char_traits<char>>(v22);
  std::ios::~ios<char,std::char_traits<char>>(v23);
  LOBYTE(v29) = 1;
  sub_10003D60((int)&v17);
  LOBYTE(v29) = 0;
  if ( v26 >= 0x10 )
    operator delete(v24[0]);
  v29 = -1;
  v26 = 15;
  v25 = 0;
  LOBYTE(v24[0]) = 0;
  if ( v28 >= 0x10 )
    operator delete(v27[0]);
  return 1;
}
// 1000709C: using guessed type int __thiscall std::ios::~ios<char,std::char_traits<char>>(_DWORD);
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 100070D0: using guessed type int __thiscall std::iostream::~basic_iostream<char,std::char_traits<char>>(_DWORD);
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 10007A34: using guessed type void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';

//----- (10002AB0) --------------------------------------------------------
int __thiscall sub_10002AB0(void ***this)
{
  void ***v2; // [esp+Ch] [ebp-10h]

  v2 = this + 24;
  *(void ***)((char *)v2 + (_DWORD)(*this)[1] - 96) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  sub_10003610(this + 6);
  std::iostream::~basic_iostream<char,std::char_traits<char>>(v2 - 18);
  return std::ios::~ios<char,std::char_traits<char>>();
}
// 1000709C: using guessed type int std::ios::~ios<char,std::char_traits<char>>(void);
// 100070D0: using guessed type int __thiscall std::iostream::~basic_iostream<char,std::char_traits<char>>(_DWORD);
// 10007A34: using guessed type void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';

//----- (10002B20) --------------------------------------------------------
int __thiscall sub_10002B20(int this, __int16 a2)
{
  FARPROC CreateSGP2PLibInstance; // eax
  int v5; // edx
  int v6; // eax
  char *v7; // eax
  _DWORD *v8; // eax
  int (__thiscall ***v9)(_DWORD, _DWORD *, _DWORD *, int (*)()); // ecx
  int v10; // esi
  _DWORD v11[7]; // [esp+10h] [ebp-74h] BYREF
  __int16 v12; // [esp+2Ch] [ebp-58h]
  _DWORD v13[7]; // [esp+30h] [ebp-54h] BYREF
  __int16 v14; // [esp+4Ch] [ebp-38h]
  _DWORD v15[7]; // [esp+50h] [ebp-34h] BYREF
  __int16 v16; // [esp+6Ch] [ebp-18h]
  char v17; // [esp+6Eh] [ebp-16h]
  __int16 v18; // [esp+70h] [ebp-14h]
  int v19; // [esp+80h] [ebp-4h]

  if ( *(_DWORD *)(this + 8) )
    return 100;
  if ( !*(_DWORD *)(this + 24) )
    return 100;
  if ( !sub_10002510(this) )
    return 100;
  CreateSGP2PLibInstance = GetProcAddress(*(HMODULE *)(this + 4), "CreateSGP2PLibInstance");
  *(_DWORD *)(this + 16) = CreateSGP2PLibInstance;
  if ( !CreateSGP2PLibInstance )
    return 100;
  sub_100025F0(this);
  *(_DWORD *)(this + 8) = (*(int (**)(void))(this + 16))();
  v11[5] = 15;
  v11[4] = 0;
  LOBYTE(v11[0]) = 0;
  v13[5] = 15;
  v13[4] = 0;
  LOBYTE(v13[0]) = 0;
  v15[5] = 15;
  v15[4] = 0;
  LOBYTE(v15[0]) = 0;
  v19 = 2;
  sub_10001AD0(
    (_BYTE *)(*(_DWORD *)(*(_DWORD *)(this + 24) + 268) + 257),
    strlen((const char *)(*(_DWORD *)(*(_DWORD *)(this + 24) + 268) + 257)),
    v11);
  v5 = *(_DWORD *)(this + 24);
  v12 = a2;
  v17 = 0;
  v18 = 2;
  v6 = *(_DWORD *)(v5 + 268);
  if ( *(_DWORD *)(v6 + 1292) == 2 )
  {
    sub_10003510("p2p-stun.iam0.co.kr", v13);
    v7 = "p2p-turn.iam0.co.kr";
LABEL_11:
    v14 = 3478;
    sub_10003510(v7, v15);
    v16 = 30001;
    goto LABEL_12;
  }
  if ( *(_DWORD *)(v6 + 1292) != 3 )
  {
    sub_10003510("p2p-stun.iam0.com", v13);
    v7 = "p2p-turn.iam0.com";
    goto LABEL_11;
  }
  sub_10003510("p2p-stun.onsandbox.com", v13);
  v14 = 3478;
  sub_10003510("p2p-turn.onsandbox.com", v15);
  v16 = 30001;
LABEL_12:
  v8 = operator new(0x14u);
  if ( v8 )
  {
    *v8 = &SGUPP2PCallbackHandler::`vftable';
    v8[1] = 0;
    v8[2] = 0;
    v8[3] = 0;
    v8[4] = 0;
  }
  else
  {
    v8 = 0;
  }
  v9 = *(int (__thiscall ****)(_DWORD, _DWORD *, _DWORD *, int (*)()))(this + 8);
  *(_DWORD *)(this + 12) = v8;
  v10 = (**v9)(v9, v11, v8, sub_10002480);
  v19 = -1;
  sub_10002D00((int)v11);
  return v10;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 100078BC: using guessed type void *SGUPP2PCallbackHandler::`vftable';

//----- (10002D00) --------------------------------------------------------
void __stdcall sub_10002D00(int a1)
{
  if ( *(_DWORD *)(a1 + 84) >= 0x10u )
    operator delete(*(void **)(a1 + 64));
  *(_DWORD *)(a1 + 84) = 15;
  *(_DWORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  if ( *(_DWORD *)(a1 + 52) >= 0x10u )
    operator delete(*(void **)(a1 + 32));
  *(_DWORD *)(a1 + 52) = 15;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
    operator delete(*(void **)a1);
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10002DB0) --------------------------------------------------------
int __thiscall sub_10002DB0(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void *v3; // eax

  v2 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = (void *)this[2];
  this[3] = 0;
  if ( v3 )
    operator delete(v3);
  this[2] = 0;
  return (*(int (__thiscall **)(_DWORD))(MEMORY[0] + 4))(0);
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10002DF0) --------------------------------------------------------
int __thiscall sub_10002DF0(_DWORD *this, __int64 a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  const char *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  int v10; // ecx
  int (__thiscall *v11)(int, int *, int, int, int); // edx
  int v12; // eax
  int v13; // ebx
  int v15; // [esp+1Ch] [ebp-88h] BYREF
  void *v16[5]; // [esp+20h] [ebp-84h] BYREF
  unsigned int v17; // [esp+34h] [ebp-70h]
  void *v18[5]; // [esp+3Ch] [ebp-68h] BYREF
  unsigned int v19; // [esp+50h] [ebp-54h]
  void *v20; // [esp+58h] [ebp-4Ch]
  int v21; // [esp+68h] [ebp-3Ch]
  unsigned int v22; // [esp+6Ch] [ebp-38h]
  void *v23[5]; // [esp+74h] [ebp-30h] BYREF
  unsigned int v24; // [esp+88h] [ebp-1Ch]
  int v25; // [esp+A0h] [ebp-4h]

  v5 = this;
  if ( !this[2] )
    return 100;
  v17 = 15;
  v16[4] = 0;
  LOBYTE(v16[0]) = 0;
  v25 = 1;
  v15 = a2;
  v7 = (const char *)sub_10002400(a2);
  v8 = (_DWORD *)sub_10004260(v7, (int)v23);
  LOBYTE(v25) = 2;
  v9 = (_DWORD *)sub_100042A0(v5 + 7, v8, (int)v18);
  LOBYTE(v25) = 3;
  sub_10003CF0(v9, (int)v16);
  LOBYTE(v25) = 2;
  if ( v19 >= 0x10 )
    operator delete(v18[0]);
  LOBYTE(v25) = 1;
  v19 = 15;
  v18[4] = 0;
  LOBYTE(v18[0]) = 0;
  if ( v24 >= 0x10 )
    operator delete(v23[0]);
  LOBYTE(v25) = 0;
  v24 = 15;
  v23[4] = 0;
  LOBYTE(v23[0]) = 0;
  if ( v22 >= 0x10 )
    operator delete(v20);
  v10 = this[2];
  v11 = *(int (__thiscall **)(int, int *, int, int, int))(*(_DWORD *)v10 + 8);
  v22 = 15;
  v21 = 0;
  LOBYTE(v20) = 0;
  v12 = v11(v10, &v15, a3, a4, a5);
  v25 = -1;
  v13 = v12;
  if ( v17 >= 0x10 )
    operator delete(v16[0]);
  return v13;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10002FE0) --------------------------------------------------------
int __thiscall sub_10002FE0(_DWORD *this, __int64 a2)
{
  _DWORD *v2; // esi
  const char *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  int v7; // ecx
  int (__thiscall *v8)(int, int *); // edx
  int v9; // eax
  int v10; // ebx
  int v12; // [esp+14h] [ebp-88h] BYREF
  void *v13[5]; // [esp+18h] [ebp-84h] BYREF
  unsigned int v14; // [esp+2Ch] [ebp-70h]
  void *v15[5]; // [esp+34h] [ebp-68h] BYREF
  unsigned int v16; // [esp+48h] [ebp-54h]
  void *v17; // [esp+50h] [ebp-4Ch]
  int v18; // [esp+60h] [ebp-3Ch]
  unsigned int v19; // [esp+64h] [ebp-38h]
  void *v20[5]; // [esp+6Ch] [ebp-30h] BYREF
  unsigned int v21; // [esp+80h] [ebp-1Ch]
  int v22; // [esp+98h] [ebp-4h]

  v2 = this;
  if ( !this[2] )
    return 100;
  v14 = 15;
  v13[4] = 0;
  LOBYTE(v13[0]) = 0;
  v22 = 1;
  v12 = a2;
  v4 = (const char *)sub_10002400(a2);
  v5 = (_DWORD *)sub_10004260(v4, (int)v15);
  LOBYTE(v22) = 2;
  v6 = (_DWORD *)sub_100042A0(v2 + 7, v5, (int)v20);
  LOBYTE(v22) = 3;
  sub_10003CF0(v6, (int)v13);
  LOBYTE(v22) = 2;
  if ( v21 >= 0x10 )
    operator delete(v20[0]);
  LOBYTE(v22) = 1;
  v21 = 15;
  v20[4] = 0;
  LOBYTE(v20[0]) = 0;
  if ( v16 >= 0x10 )
    operator delete(v15[0]);
  LOBYTE(v22) = 0;
  v16 = 15;
  v15[4] = 0;
  LOBYTE(v15[0]) = 0;
  if ( v19 >= 0x10 )
    operator delete(v17);
  v7 = this[2];
  v8 = *(int (__thiscall **)(int, int *))(*(_DWORD *)v7 + 12);
  v19 = 15;
  v18 = 0;
  LOBYTE(v17) = 0;
  v9 = v8(v7, &v12);
  v22 = -1;
  v10 = v9;
  if ( v14 >= 0x10 )
    operator delete(v13[0]);
  return v10;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003180) --------------------------------------------------------
int __thiscall sub_10003180(_DWORD *this, __int64 a2)
{
  _DWORD *v2; // esi
  const char *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  int v7; // ecx
  int (__thiscall *v8)(int, int *); // edx
  int v9; // eax
  int v10; // ebx
  int v12; // [esp+14h] [ebp-88h] BYREF
  void *v13[5]; // [esp+18h] [ebp-84h] BYREF
  unsigned int v14; // [esp+2Ch] [ebp-70h]
  void *v15[5]; // [esp+34h] [ebp-68h] BYREF
  unsigned int v16; // [esp+48h] [ebp-54h]
  void *v17; // [esp+50h] [ebp-4Ch]
  int v18; // [esp+60h] [ebp-3Ch]
  unsigned int v19; // [esp+64h] [ebp-38h]
  void *v20[5]; // [esp+6Ch] [ebp-30h] BYREF
  unsigned int v21; // [esp+80h] [ebp-1Ch]
  int v22; // [esp+98h] [ebp-4h]

  v2 = this;
  if ( !this[2] )
    return 100;
  v14 = 15;
  v13[4] = 0;
  LOBYTE(v13[0]) = 0;
  v22 = 1;
  v12 = a2;
  v4 = (const char *)sub_10002400(a2);
  v5 = (_DWORD *)sub_10004260(v4, (int)v15);
  LOBYTE(v22) = 2;
  v6 = (_DWORD *)sub_100042A0(v2 + 7, v5, (int)v20);
  LOBYTE(v22) = 3;
  sub_10003CF0(v6, (int)v13);
  LOBYTE(v22) = 2;
  if ( v21 >= 0x10 )
    operator delete(v20[0]);
  LOBYTE(v22) = 1;
  v21 = 15;
  v20[4] = 0;
  LOBYTE(v20[0]) = 0;
  if ( v16 >= 0x10 )
    operator delete(v15[0]);
  LOBYTE(v22) = 0;
  v16 = 15;
  v15[4] = 0;
  LOBYTE(v15[0]) = 0;
  if ( v19 >= 0x10 )
    operator delete(v17);
  v7 = this[2];
  v8 = *(int (__thiscall **)(int, int *))(*(_DWORD *)v7 + 16);
  v19 = 15;
  v18 = 0;
  LOBYTE(v17) = 0;
  v9 = v8(v7, &v12);
  v22 = -1;
  v10 = v9;
  if ( v14 >= 0x10 )
    operator delete(v13[0]);
  return v10;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003320) --------------------------------------------------------
int __thiscall sub_10003320(_DWORD *this, __int64 a2, bool *a3)
{
  const char *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // ecx
  int (__thiscall *v9)(int, int *, int *); // edx
  int v10; // edi
  bool *v11; // eax
  bool v12; // zf
  bool v13; // dl
  int v14; // edx
  int v15[2]; // [esp+14h] [ebp-98h] BYREF
  bool *v16; // [esp+1Ch] [ebp-90h]
  _DWORD *v17; // [esp+20h] [ebp-8Ch]
  int v18; // [esp+24h] [ebp-88h] BYREF
  void *v19[5]; // [esp+28h] [ebp-84h] BYREF
  unsigned int v20; // [esp+3Ch] [ebp-70h]
  void *v21[5]; // [esp+44h] [ebp-68h] BYREF
  unsigned int v22; // [esp+58h] [ebp-54h]
  void *v23; // [esp+60h] [ebp-4Ch]
  int v24; // [esp+70h] [ebp-3Ch]
  unsigned int v25; // [esp+74h] [ebp-38h]
  void *v26[5]; // [esp+7Ch] [ebp-30h] BYREF
  unsigned int v27; // [esp+90h] [ebp-1Ch]
  int v28; // [esp+A8h] [ebp-4h]

  v17 = this;
  v16 = a3;
  if ( !this[2] || !a3 )
    return 100;
  v20 = 15;
  v19[4] = 0;
  LOBYTE(v19[0]) = 0;
  v28 = 1;
  v18 = a2;
  v5 = (const char *)sub_10002400(a2);
  v6 = (_DWORD *)sub_10004260(v5, (int)v26);
  LOBYTE(v28) = 2;
  v7 = (_DWORD *)sub_100042A0(this + 7, v6, (int)v21);
  LOBYTE(v28) = 3;
  sub_10003CF0(v7, (int)v19);
  LOBYTE(v28) = 2;
  if ( v22 >= 0x10 )
    operator delete(v21[0]);
  LOBYTE(v28) = 1;
  v22 = 15;
  v21[4] = 0;
  LOBYTE(v21[0]) = 0;
  if ( v27 >= 0x10 )
    operator delete(v26[0]);
  LOBYTE(v28) = 0;
  v27 = 15;
  v26[4] = 0;
  LOBYTE(v26[0]) = 0;
  if ( v25 >= 0x10 )
    operator delete(v23);
  v8 = v17[2];
  v9 = *(int (__thiscall **)(int, int *, int *))(*(_DWORD *)v8 + 20);
  v25 = 15;
  v24 = 0;
  LOBYTE(v23) = 0;
  v10 = v9(v8, &v18, v15);
  v11 = v16;
  v12 = BYTE1(v15[0]) == 0;
  *v16 = LOBYTE(v15[0]) != 0;
  v13 = !v12;
  v12 = BYTE2(v15[0]) == 0;
  v11[1] = v13;
  v14 = v15[1];
  v28 = -1;
  v11[2] = !v12;
  *((_DWORD *)v11 + 2) = v14;
  *((_DWORD *)v11 + 3) = 0;
  if ( v20 >= 0x10 )
    operator delete(v19[0]);
  return v10;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003510) --------------------------------------------------------
int __userpurge sub_10003510@<eax>(char *a1@<eax>, _DWORD *a2)
{
  return sub_10001AD0(a1, strlen(a1), a2);
}

//----- (10003550) --------------------------------------------------------
_DWORD *__thiscall sub_10003550(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // eax

  *a2 = &unk_10007A38;
  a2[4] = &unk_10007A40;
  std::ios::ios(a2 + 24);
  std::iostream::basic_iostream<char>(a2, a2 + 6, 0);
  *(_DWORD *)((char *)a2 + *(_DWORD *)(*a2 + 4)) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  std::streambuf::streambuf(a2 + 6);
  a2[6] = &std::stringbuf::`vftable';
  v3 = this[4];
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  a2[21] = 0;
  a2[22] = 0;
  if ( v3 )
    sub_10004070(v3, (int)(a2 + 6), this);
  return a2;
}
// 100070B8: using guessed type int __thiscall std::streambuf::streambuf(_DWORD);
// 100070BC: using guessed type int __thiscall std::iostream::basic_iostream<char>(_DWORD, _DWORD, _DWORD);
// 100070C4: using guessed type int __thiscall std::ios::ios(_DWORD);
// 100079F4: using guessed type void *std::stringbuf::`vftable';
// 10007A34: using guessed type void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';

//----- (10003610) --------------------------------------------------------
int __thiscall sub_10003610(void ***this)
{
  *this = &std::stringbuf::`vftable';
  if ( ((_BYTE)this[16] & 1) != 0 )
    operator delete(*this[4]);
  *this[4] = 0;
  *this[8] = 0;
  *this[12] = 0;
  *this[5] = 0;
  *this[9] = 0;
  *this[13] = 0;
  this[16] = (void **)((unsigned int)this[16] & 0xFFFFFFFE);
  this[15] = 0;
  return std::streambuf::~streambuf<char,std::char_traits<char>>();
}
// 1000706C: using guessed type int std::streambuf::~streambuf<char,std::char_traits<char>>(void);
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 100079F4: using guessed type void *std::stringbuf::`vftable';

//----- (100036C0) --------------------------------------------------------
int __thiscall sub_100036C0(int this, int a2)
{
  unsigned int *v3; // edi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  unsigned int v8; // ecx
  size_t v9; // ebx
  unsigned int v10; // eax
  _BYTE *v11; // eax
  void *v12; // edx
  _BYTE *v13; // edi
  _DWORD *v14; // eax
  int *v15; // ecx
  int v16; // eax
  char *v17; // eax
  int v18; // ecx
  char *v19; // eax
  void *v20; // [esp+Ch] [ebp-8h]
  unsigned int v21; // [esp+10h] [ebp-4h]

  if ( (*(_BYTE *)(this + 64) & 8) != 0 )
  {
    v3 = *(unsigned int **)(this + 36);
    v4 = *v3;
    if ( *v3 )
    {
      v5 = *(_DWORD *)(this + 60);
      if ( v4 < v5 )
      {
        v6 = v4 + **(_DWORD **)(this + 52);
        *v3 = v5;
        **(_DWORD **)(this + 52) = v6 - v5;
      }
    }
  }
  if ( a2 == -1 )
    return 0;
  v8 = **(_DWORD **)(this + 36);
  if ( v8 && v8 < v8 + **(_DWORD **)(this + 52) )
  {
    *(_BYTE *)std::streambuf::_Pninc(this) = a2;
    return a2;
  }
  if ( (*(_BYTE *)(this + 64) & 2) != 0 )
    return -1;
  if ( v8 )
    v9 = v8 + **(_DWORD **)(this + 52) - **(_DWORD **)(this + 16);
  else
    v9 = 0;
  v10 = v9 >> 1;
  if ( v9 >> 1 >= 0x20 )
  {
    if ( !v10 )
      return -1;
  }
  else
  {
    v10 = 32;
  }
  do
  {
    if ( 0x7FFFFFFF - v10 >= v9 )
      break;
    v10 >>= 1;
  }
  while ( v10 );
  if ( !v10 )
    return -1;
  v21 = v10 + v9;
  v11 = sub_10001DF0((void *)(v10 + v9));
  v12 = **(void ***)(this + 16);
  v13 = v11;
  v20 = v12;
  if ( v9 )
  {
    memcpy(v11, v12, v9);
    v12 = v20;
    v15 = *(int **)(this + 36);
    *(_DWORD *)(this + 60) += v13 - (_BYTE *)v20;
    v16 = *v15;
    **(_DWORD **)(this + 20) += v13 - (_BYTE *)v20;
    v17 = &v13[v16 - (_DWORD)v20];
    **(_DWORD **)(this + 36) = v17;
    **(_DWORD **)(this + 52) = v21 + v13 - v17;
    if ( (*(_BYTE *)(this + 64) & 4) != 0 )
    {
      **(_DWORD **)(this + 16) = v13;
      **(_DWORD **)(this + 32) = 0;
      **(_DWORD **)(this + 48) = v13;
    }
    else
    {
      v18 = **(_DWORD **)(this + 36);
      v19 = &v13[**(_DWORD **)(this + 32) - (_DWORD)v20];
      **(_DWORD **)(this + 16) = v13;
      **(_DWORD **)(this + 32) = v19;
      **(_DWORD **)(this + 48) = v18 - (_DWORD)v19 + 1;
    }
  }
  else
  {
    v14 = *(_DWORD **)(this + 20);
    *(_DWORD *)(this + 60) = v13;
    *v14 = v13;
    **(_DWORD **)(this + 36) = v13;
    **(_DWORD **)(this + 52) = v21;
    if ( (*(_BYTE *)(this + 64) & 4) != 0 )
    {
      **(_DWORD **)(this + 16) = v13;
      **(_DWORD **)(this + 32) = 0;
      **(_DWORD **)(this + 48) = v13;
    }
    else
    {
      **(_DWORD **)(this + 16) = v13;
      **(_DWORD **)(this + 32) = v13;
      **(_DWORD **)(this + 48) = 1;
    }
  }
  if ( (*(_BYTE *)(this + 64) & 1) != 0 )
    operator delete(v12);
  *(_DWORD *)(this + 64) |= 1u;
  *(_BYTE *)std::streambuf::_Pninc(this) = a2;
  return a2;
}
// 100037AC: conditional instruction was optimized away because of 'ebx.4!=0'
// 100070C8: using guessed type int __thiscall std::streambuf::_Pninc(_DWORD);
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003890) --------------------------------------------------------
int __thiscall sub_10003890(int this, int a2)
{
  unsigned int v2; // eax

  v2 = **(_DWORD **)(this + 32);
  if ( !v2
    || v2 <= **(_DWORD **)(this + 16)
    || a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && (*(_BYTE *)(this + 64) & 2) != 0 )
  {
    return -1;
  }
  ++**(_DWORD **)(this + 48);
  --**(_DWORD **)(this + 32);
  if ( a2 == -1 )
    return 0;
  ***(_BYTE ***)(this + 32) = a2;
  return a2;
}

//----- (100038E0) --------------------------------------------------------
int __thiscall sub_100038E0(int this)
{
  unsigned __int8 **v1; // edx
  unsigned __int8 *v2; // esi
  _DWORD *v4; // edi
  unsigned int v5; // eax

  v1 = *(unsigned __int8 ***)(this + 32);
  v2 = *v1;
  if ( !*v1 )
    return -1;
  v4 = *(_DWORD **)(this + 48);
  if ( v2 < &v2[*v4] )
    return *v2;
  if ( (*(_BYTE *)(this + 64) & 4) != 0 )
    return -1;
  v5 = **(_DWORD **)(this + 36);
  if ( !v5 || v5 <= (unsigned int)v2 && *(_DWORD *)(this + 60) <= (unsigned int)v2 )
    return -1;
  if ( *(_DWORD *)(this + 60) < v5 )
    *(_DWORD *)(this + 60) = v5;
  *v4 = *(_DWORD *)(this + 60) - (_DWORD)*v1;
  return ***(unsigned __int8 ***)(this + 32);
}

//----- (10003950) --------------------------------------------------------
unsigned int *__thiscall sub_10003950(int this, unsigned int *a2, __int64 a3, int a4, char a5)
{
  unsigned int *v5; // edx
  unsigned int v6; // eax
  int v7; // eax
  int v8; // ebx
  unsigned int v9; // esi
  int v10; // edi
  unsigned int v11; // edi
  _DWORD *v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // edi
  unsigned int v16; // edi
  unsigned int *result; // eax

  v5 = *(unsigned int **)(this + 36);
  v6 = *v5;
  if ( *v5 && *(_DWORD *)(this + 60) < v6 )
    *(_DWORD *)(this + 60) = v6;
  if ( (a5 & 1) == 0 || (v7 = **(_DWORD **)(this + 32)) == 0 )
  {
    if ( (a5 & 2) != 0 && *v5 )
    {
      if ( a4 == 2 )
      {
        v8 = (unsigned __int64)(*(_DWORD *)(this + 60) - **(_DWORD **)(this + 16) + a3) >> 32;
        v9 = *(_DWORD *)(this + 60) - **(_DWORD **)(this + 16) + a3;
      }
      else if ( a4 == 1 )
      {
        v8 = (unsigned __int64)((int)(*v5 - **(_DWORD **)(this + 16)) + a3) >> 32;
        v9 = *v5 - **(_DWORD **)(this + 16) + a3;
      }
      else if ( a4 )
      {
        v9 = std::_BADOFF;
        v8 = HIDWORD(std::_BADOFF);
      }
      else
      {
        v8 = HIDWORD(a3);
        v9 = a3;
      }
      if ( v8 >= 0 )
      {
        v15 = **(_DWORD **)(this + 16);
        if ( __SPAIR64__(v8, v9) <= *(_DWORD *)(this + 60) - v15 )
        {
          v16 = v9 + v15 - *v5;
          **(_DWORD **)(this + 52) -= v16;
          **(_DWORD **)(this + 36) += v16;
          goto LABEL_33;
        }
      }
    }
    else
    {
      v8 = HIDWORD(a3);
      v9 = a3;
      if ( !a3 )
        goto LABEL_33;
    }
LABEL_32:
    v9 = std::_BADOFF;
    v8 = HIDWORD(std::_BADOFF);
    goto LABEL_33;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( (a5 & 2) == 0 )
      {
        v8 = (unsigned __int64)(v7 - **(_DWORD **)(this + 16) + a3) >> 32;
        v9 = v7 - **(_DWORD **)(this + 16) + a3;
        goto LABEL_14;
      }
    }
    else if ( !a4 )
    {
      v8 = HIDWORD(a3);
      v9 = a3;
      goto LABEL_14;
    }
    v9 = std::_BADOFF;
    v8 = HIDWORD(std::_BADOFF);
    goto LABEL_14;
  }
  v8 = (unsigned __int64)(*(_DWORD *)(this + 60) - **(_DWORD **)(this + 16) + a3) >> 32;
  v9 = *(_DWORD *)(this + 60) - **(_DWORD **)(this + 16) + a3;
LABEL_14:
  if ( v8 < 0 )
    goto LABEL_32;
  v10 = **(_DWORD **)(this + 16);
  if ( __SPAIR64__(v8, v9) > *(_DWORD *)(this + 60) - v10 )
    goto LABEL_32;
  v11 = v9 + v10 - v7;
  **(_DWORD **)(this + 48) -= v11;
  **(_DWORD **)(this + 32) += v11;
  if ( (a5 & 2) != 0 )
  {
    v12 = *(_DWORD **)(this + 36);
    if ( *v12 )
    {
      v13 = *v12 + **(_DWORD **)(this + 52);
      v14 = **(_DWORD **)(this + 32);
      *v12 = v14;
      **(_DWORD **)(this + 52) = v13 - v14;
    }
  }
LABEL_33:
  result = a2;
  *a2 = v9;
  a2[1] = v8;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  return result;
}
// 100070B4: using guessed type const __int64 std::_BADOFF;

//----- (10003B00) --------------------------------------------------------
unsigned int *__thiscall sub_10003B00(int this, unsigned int *a2, __int64 a3, int a4, int a5, int a6, int a7, char a8)
{
  int v8; // ebx
  unsigned int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // edi
  int v12; // eax
  int v13; // edi
  unsigned int v14; // edi
  _DWORD *v15; // edi
  int v16; // eax
  int v17; // edx
  int v18; // edi
  unsigned int v19; // edi
  unsigned int *result; // eax
  int v21; // [esp+Ch] [ebp-Ch]
  int v22; // [esp+Ch] [ebp-Ch]

  v10 = **(_DWORD **)(this + 36);
  v8 = (unsigned __int64)(a3 + a4) >> 32;
  v9 = a3 + a4;
  if ( v10 && *(_DWORD *)(this + 60) < v10 )
    *(_DWORD *)(this + 60) = v10;
  v11 = std::_BADOFF;
  v12 = HIDWORD(std::_BADOFF);
  if ( v9 != (_DWORD)std::_BADOFF || v8 != v12 )
  {
    if ( (a8 & 1) != 0 && (v21 = **(_DWORD **)(this + 32)) != 0 )
    {
      if ( v8 < 0 )
      {
LABEL_19:
        v9 = v11;
        v8 = v12;
        goto LABEL_20;
      }
      v13 = **(_DWORD **)(this + 16);
      if ( __SPAIR64__(v8, v9) <= *(_DWORD *)(this + 60) - v13 )
      {
        v14 = v9 + v13 - v21;
        **(_DWORD **)(this + 48) -= v14;
        **(_DWORD **)(this + 32) += v14;
        if ( (a8 & 2) != 0 )
        {
          v15 = *(_DWORD **)(this + 36);
          if ( *v15 )
          {
            v16 = *v15 + **(_DWORD **)(this + 52);
            v17 = **(_DWORD **)(this + 32);
            *v15 = v17;
            **(_DWORD **)(this + 52) = v16 - v17;
          }
        }
        goto LABEL_20;
      }
    }
    else
    {
      if ( (a8 & 2) == 0 )
        goto LABEL_19;
      v22 = **(_DWORD **)(this + 36);
      if ( !v22 || v8 < 0 )
        goto LABEL_19;
      v18 = **(_DWORD **)(this + 16);
      if ( __SPAIR64__(v8, v9) <= *(_DWORD *)(this + 60) - v18 )
      {
        v19 = v9 + v18 - v22;
        **(_DWORD **)(this + 52) -= v19;
        **(_DWORD **)(this + 36) += v19;
        goto LABEL_20;
      }
    }
    v12 = HIDWORD(std::_BADOFF);
    v11 = std::_BADOFF;
    goto LABEL_19;
  }
LABEL_20:
  result = a2;
  *a2 = v9;
  a2[1] = v8;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  return result;
}
// 100070B4: using guessed type const __int64 std::_BADOFF;

//----- (10003C30) --------------------------------------------------------
void ***__thiscall sub_10003C30(void ***this, char a2)
{
  void ***v2; // ebx
  void ***v3; // edi

  v2 = this - 24;
  *(void ***)((char *)this + (_DWORD)(*(this - 24))[1] - 96) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  v3 = this - 18;
  sub_10003610(this - 18);
  std::iostream::~basic_iostream<char,std::char_traits<char>>(v3);
  std::ios::~ios<char,std::char_traits<char>>(v2 + 24);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return v2;
}
// 1000709C: using guessed type int __thiscall std::ios::~ios<char,std::char_traits<char>>(_DWORD);
// 100070D0: using guessed type int __thiscall std::iostream::~basic_iostream<char,std::char_traits<char>>(_DWORD);
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 10007A34: using guessed type void *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';

//----- (10003CC0) --------------------------------------------------------
void ***__thiscall sub_10003CC0(void ***this, char a2)
{
  sub_10003610(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003CF0) --------------------------------------------------------
int __usercall sub_10003CF0@<eax>(_DWORD *a1@<edi>, int a2@<esi>)
{
  if ( (_DWORD *)a2 != a1 )
  {
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
      operator delete(*(void **)a2);
    *(_DWORD *)(a2 + 20) = 15;
    *(_DWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
    if ( a1[5] >= 0x10u )
    {
      *(_DWORD *)a2 = *a1;
      *a1 = 0;
    }
    else
    {
      memmove((void *)a2, a1, a1[4] + 1);
    }
    *(_DWORD *)(a2 + 16) = a1[4];
    *(_DWORD *)(a2 + 20) = a1[5];
    a1[5] = 15;
    a1[4] = 0;
    *(_BYTE *)a1 = 0;
  }
  return a2;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003D60) --------------------------------------------------------
int __usercall sub_10003D60@<eax>(int a1@<ebx>)
{
  void **v1; // esi
  void **i; // edi
  int result; // eax

  v1 = *(void ***)a1;
  if ( *(_DWORD *)a1 )
  {
    for ( i = *(void ***)(a1 + 4); v1 != i; v1 += 7 )
    {
      if ( (unsigned int)v1[5] >= 0x10 )
        operator delete(*v1);
      v1[5] = (void *)15;
      v1[4] = 0;
      *(_BYTE *)v1 = 0;
    }
    operator delete(*(void **)a1);
  }
  result = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10003DC0) --------------------------------------------------------
char *__usercall sub_10003DC0@<eax>(const char *a1@<eax>, size_t a2@<ebx>)
{
  char *v2; // edi
  unsigned int v3; // ecx
  _DWORD *v4; // eax
  char *v5; // eax
  char *result; // eax
  int v7; // eax
  size_t v8; // esi
  _DWORD *v9; // eax
  bool v10; // cf

  v2 = (char *)a1;
  v3 = *((_DWORD *)a1 + 5);
  if ( v3 >= 0x10 )
    a1 = *(const char **)a1;
  if ( a1 > "@" || (v3 < 0x10 ? (v4 = v2) : (v4 = *(_DWORD **)v2), (char *)v4 + *((_DWORD *)v2 + 4) <= "@") )
  {
    v7 = *((_DWORD *)v2 + 4);
    if ( -1 - v7 <= a2 )
      std::_Xlength_error("string too long");
    if ( a2 )
    {
      v8 = v7 + a2;
      if ( sub_10001C20(v2, v7 + a2) )
      {
        if ( *((_DWORD *)v2 + 5) < 0x10u )
          v9 = v2;
        else
          v9 = *(_DWORD **)v2;
        memcpy((char *)v9 + *((_DWORD *)v2 + 4), "@", a2);
        v10 = *((_DWORD *)v2 + 5) < 0x10u;
        *((_DWORD *)v2 + 4) = v8;
        if ( !v10 )
        {
          *(_BYTE *)(*(_DWORD *)v2 + v8) = 0;
          return v2;
        }
        v2[v8] = 0;
      }
    }
    result = v2;
  }
  else
  {
    if ( v3 < 0x10 )
      v5 = v2;
    else
      v5 = *(char **)v2;
    result = (char *)sub_10004150(a2, v2, v2, "@" - v5);
  }
  return result;
}
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (10003E80) --------------------------------------------------------
_DWORD *__usercall sub_10003E80@<eax>(char a1@<bl>, _DWORD *a2@<esi>)
{
  size_t v2; // ecx
  unsigned int v3; // edi
  unsigned int v4; // eax
  _BYTE *v5; // eax
  _DWORD *result; // eax

  v2 = a2[4];
  if ( v2 == -1 || v2 == -2 )
    std::_Xlength_error("string too long");
  v3 = v2 + 1;
  if ( v2 == -2 )
    std::_Xlength_error("string too long");
  v4 = a2[5];
  if ( v4 < v3 )
  {
    sub_10001C70((int)a2, v2 + 1, v2);
    if ( !v3 )
      return a2;
LABEL_7:
    if ( a2[5] < 0x10u )
      v5 = a2;
    else
      v5 = (_BYTE *)*a2;
    v5[a2[4]] = a1;
    a2[4] = v3;
    if ( a2[5] >= 0x10u )
    {
      *(_BYTE *)(*a2 + v3) = 0;
      return a2;
    }
    *((_BYTE *)a2 + v3) = 0;
    return a2;
  }
  if ( v2 != -1 )
    goto LABEL_7;
  a2[4] = 0;
  if ( v4 < 0x10 )
  {
    result = a2;
    *(_BYTE *)a2 = 0;
  }
  else
  {
    *(_BYTE *)*a2 = 0;
    result = a2;
  }
  return result;
}
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (10003F10) --------------------------------------------------------
unsigned int __thiscall sub_10003F10(int *this, unsigned int a2)
{
  unsigned int result; // eax
  void *v4; // eax
  int v5; // ebx
  int v6; // [esp-Ch] [ebp-30h]
  int v7; // [esp+0h] [ebp-24h] BYREF
  signed int v8; // [esp+10h] [ebp-14h]
  int *v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+20h] [ebp-4h]

  v9 = &v7;
  if ( a2 > 0x9249249 )
    std::_Xlength_error("vector<T> too long");
  result = (this[2] - *this) / 28;
  if ( result < a2 )
  {
    v4 = sub_10004200(a2);
    v10 = 0;
    v6 = this[1];
    v8 = (signed int)v4;
    sub_10004450(v6, v4);
    v10 = -1;
    v5 = (this[1] - *this) / 28;
    if ( *this )
    {
      sub_10004030(*this, this[1]);
      operator delete((void *)*this);
    }
    result = v8;
    this[2] = v8 + 28 * a2;
    this[1] = result + 28 * v5;
    *this = result;
  }
  return result;
}
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10004030) --------------------------------------------------------
void __usercall sub_10004030(int a1@<eax>, int a2@<edi>)
{
  int i; // esi

  for ( i = a1; i != a2; i += 28 )
  {
    if ( *(_DWORD *)(i + 20) >= 0x10u )
      operator delete(*(void **)i);
    *(_DWORD *)(i + 20) = 15;
    *(_DWORD *)(i + 16) = 0;
    *(_BYTE *)i = 0;
  }
}
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10004070) --------------------------------------------------------
char *__userpurge sub_10004070@<eax>(unsigned int a1@<ebx>, int a2@<esi>, void *Src)
{
  char *result; // eax
  char *v4; // edi
  bool v5; // zf
  int v6; // ecx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char *)(*(_DWORD *)(a2 + 64) & 6);
  if ( (_BYTE)result != 6 )
  {
    v4 = 0;
    if ( a1 )
    {
      v4 = (char *)operator new(a1);
      if ( !v4 )
      {
        Src = 0;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&Src);
        pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
    }
    memcpy(v4, Src, a1);
    v5 = (*(_BYTE *)(a2 + 64) & 4) == 0;
    result = &v4[a1];
    *(_DWORD *)(a2 + 60) = &v4[a1];
    if ( v5 )
    {
      **(_DWORD **)(a2 + 16) = v4;
      **(_DWORD **)(a2 + 32) = v4;
      **(_DWORD **)(a2 + 48) = a1;
    }
    v6 = *(_DWORD *)(a2 + 64);
    if ( (v6 & 2) == 0 )
    {
      if ( (v6 & 0x10) == 0 )
        result = v4;
      **(_DWORD **)(a2 + 20) = v4;
      **(_DWORD **)(a2 + 36) = result;
      **(_DWORD **)(a2 + 52) = a1 + v4 - result;
      result = *(char **)(a2 + 32);
      if ( !*(_DWORD *)result )
      {
        **(_DWORD **)(a2 + 16) = v4;
        **(_DWORD **)(a2 + 32) = 0;
        result = *(char **)(a2 + 48);
        *(_DWORD *)result = v4;
      }
    }
    *(_DWORD *)(a2 + 64) |= 1u;
  }
  return result;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007140: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (10004150) --------------------------------------------------------
_DWORD *__userpurge sub_10004150@<eax>(size_t a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3, unsigned int a4)
{
  unsigned int v6; // eax
  size_t v7; // eax
  int v8; // eax
  size_t v9; // esi
  _DWORD *v10; // ecx
  _DWORD *v11; // eax
  bool v12; // cf

  v6 = a3[4];
  if ( v6 < a4 )
    std::_Xout_of_range("invalid string position");
  v7 = v6 - a4;
  if ( v7 < a1 )
    a1 = v7;
  v8 = a2[4];
  if ( -1 - v8 <= a1 )
    std::_Xlength_error("string too long");
  if ( a1 )
  {
    v9 = v8 + a1;
    if ( sub_10001C20(a2, v8 + a1) )
    {
      v10 = a3;
      if ( a3[5] >= 0x10u )
        v10 = (_DWORD *)*a3;
      if ( a2[5] < 0x10u )
        v11 = a2;
      else
        v11 = (_DWORD *)*a2;
      memcpy((char *)v11 + a2[4], (char *)v10 + a4, a1);
      v12 = a2[5] < 0x10u;
      a2[4] = v9;
      if ( !v12 )
      {
        *(_BYTE *)(*a2 + v9) = 0;
        return a2;
      }
      *((_BYTE *)a2 + v9) = 0;
    }
  }
  return a2;
}
// 1000416E: variable 'v6' is possibly undefined
// 1000416E: variable 'a4' is possibly undefined
// 100070A8: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 100070B0: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (10004200) --------------------------------------------------------
void *__fastcall sub_10004200(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  const char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x9249249 || (result = operator new(28 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, &v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007140: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 10007898: using guessed type void *std::bad_alloc::`vftable';

//----- (10004260) --------------------------------------------------------
int __usercall sub_10004260@<eax>(const char *a1@<eax>, int a2@<ecx>)
{
  char *v3; // eax

  v3 = sub_10003DC0(a1, 1u);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  sub_10003CF0(v3, a2);
  return a2;
}

//----- (100042A0) --------------------------------------------------------
int __usercall sub_100042A0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  _DWORD *v4; // eax

  v4 = sub_10004150(0xFFFFFFFF, a2, a1, 0);
  *(_DWORD *)(a3 + 20) = 15;
  *(_DWORD *)(a3 + 16) = 0;
  *(_BYTE *)a3 = 0;
  sub_10003CF0(v4, a3);
  return a3;
}

//----- (100042E0) --------------------------------------------------------
int __cdecl sub_100042E0(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  int v3; // ecx
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v10; // [esp+0h] [ebp-30h] BYREF
  int v11; // [esp+10h] [ebp-20h]
  char v12; // [esp+14h] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-18h]
  char v14; // [esp+1Fh] [ebp-11h]
  int *v15; // [esp+20h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-4h]

  v15 = &v10;
  v2 = v1;
  v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
  v4 = 0;
  v13 = 0;
  v14 = 0;
  v11 = a1;
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v16 = 0;
  v12 = std::istream::_Ipfx(a1, 1);
  v16 = 1;
  if ( !v12 )
    goto LABEL_13;
  LOBYTE(v16) = 2;
  sub_10001BA0(0xFFFFFFFF, 0, v2);
  v5 = std::streambuf::sgetc(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56));
  while ( 1 )
  {
    if ( v5 == -1 )
    {
      v4 |= 1u;
      v16 = 1;
      goto LABEL_12;
    }
    if ( v5 == 64 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
      v14 = 1;
      std::streambuf::sbumpc(v6);
      v16 = 1;
      goto LABEL_12;
    }
    if ( v2[4] >= 0xFFFFFFFE )
      break;
    sub_10003E80(v5, v2);
    v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
    v14 = 1;
    v5 = std::streambuf::snextc(v7);
    v4 = v13;
  }
  v4 |= 2u;
  v16 = 1;
LABEL_12:
  if ( !v14 )
LABEL_13:
    v4 |= 2u;
  std::ios::setstate(a1 + *(_DWORD *)(*(_DWORD *)a1 + 4), v4, 0);
  v16 = -1;
  v8 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v11 + 4) + v11 + 56);
  if ( v8 )
    (*(void (**)(void))(*(_DWORD *)v8 + 8))();
  return a1;
}
// 1000430B: variable 'v1' is possibly undefined
// 10007070: using guessed type int __thiscall std::streambuf::sgetc(_DWORD);
// 10007074: using guessed type int __thiscall std::streambuf::snextc(_DWORD);
// 100070A0: using guessed type int __thiscall std::ios::setstate(_DWORD, _DWORD, _DWORD);
// 100070C0: using guessed type int __thiscall std::istream::_Ipfx(_DWORD, _DWORD);
// 100070CC: using guessed type int __thiscall std::streambuf::sbumpc(_DWORD);

//----- (10004450) --------------------------------------------------------
_DWORD *__cdecl sub_10004450(int a1, void *a2)
{
  void *Src; // ecx
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  _DWORD v6[6]; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  v6[5] = v6;
  v3 = a2;
  v4 = Src;
  v6[4] = a2;
  v7 = 0;
  while ( v4 != (_DWORD *)a1 )
  {
    LOBYTE(v7) = 1;
    if ( v3 )
    {
      v3[5] = 15;
      v3[4] = 0;
      *(_BYTE *)v3 = 0;
      if ( v3 != v4 )
      {
        if ( v3[5] >= 0x10u )
          operator delete((void *)*v3);
        v3[5] = 15;
        v3[4] = 0;
        *(_BYTE *)v3 = 0;
        if ( v4[5] >= 0x10u )
        {
          *v3 = *v4;
          *v4 = 0;
        }
        else
        {
          memmove(v3, v4, v4[4] + 1);
        }
        v3[4] = v4[4];
        v3[5] = v4[5];
        v4[5] = 15;
        v4[4] = 0;
        *(_BYTE *)v4 = 0;
      }
    }
    v3 += 7;
    LOBYTE(v7) = 0;
    v4 += 7;
  }
  return v3;
}
// 1000447E: variable 'Src' is possibly undefined
// 1000714C: using guessed type void __cdecl operator delete(void *);

//----- (10004550) --------------------------------------------------------
char __thiscall sub_10004550(_DWORD *this)
{
  int v1; // eax
  char result; // al

  v1 = this[1];
  if ( v1 )
    result = **(_BYTE **)(v1 + 268);
  else
    result = 0;
  return result;
}

//----- (10004570) --------------------------------------------------------
int __thiscall sub_10004570(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[1];
  if ( v1 )
    result = *(_DWORD *)(v1 + 268) + 1;
  else
    result = 0;
  return result;
}

//----- (10004590) --------------------------------------------------------
int __thiscall sub_10004590(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[1];
  if ( v1 )
    result = *(_DWORD *)(v1 + 268) + 257;
  else
    result = 0;
  return result;
}

//----- (100045B0) --------------------------------------------------------
int __thiscall sub_100045B0(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[1];
  if ( v1 )
    result = *(_DWORD *)(v1 + 268) + 514;
  else
    result = 0;
  return result;
}

//----- (100045D0) --------------------------------------------------------
int __thiscall sub_100045D0(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[1];
  if ( v1 )
    result = *(_DWORD *)(v1 + 268) + 1032;
  else
    result = 0;
  return result;
}

//----- (100045F0) --------------------------------------------------------
__int64 __thiscall sub_100045F0(_DWORD *this)
{
  int v1; // eax
  __int64 result; // rax

  v1 = this[1];
  if ( v1 )
    LODWORD(result) = *(_DWORD *)(*(_DWORD *)(v1 + 268) + 1028);
  else
    LODWORD(result) = 0;
  HIDWORD(result) = 0;
  return result;
}

//----- (10004610) --------------------------------------------------------
int __cdecl sub_10004610(int a1, char *Source)
{
  int result; // eax
  bool v3; // zf
  int (__thiscall **v4)(_DWORD, int *); // edx
  int *v5; // eax
  int (__thiscall ***v6)(_DWORD, int *); // ecx
  int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  char *v11; // edi
  int v12; // eax
  int v13; // ebx
  int *v14; // edi
  int v15; // eax
  char *v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  char v20; // dl
  int v21; // eax
  char *v22; // edi
  const char *v23; // esi
  char *v24; // [esp+Ch] [ebp-4104h] BYREF
  int v25; // [esp+10h] [ebp-4100h] BYREF
  char v26[4]; // [esp+14h] [ebp-40FCh] BYREF
  int v27; // [esp+18h] [ebp-40F8h]
  int v28; // [esp+1Ch] [ebp-40F4h]
  int v29; // [esp+20h] [ebp-40F0h]
  int v30; // [esp+24h] [ebp-40ECh]
  char v31[392]; // [esp+28h] [ebp-40E8h] BYREF
  int v32[652]; // [esp+1B0h] [ebp-3F60h] BYREF
  int v33[3403]; // [esp+BE0h] [ebp-3530h] BYREF

  result = a1 - 1;
  switch ( a1 )
  {
    case 7:
      if ( Source && dword_1000B15C )
      {
        memset(v32, 0, 0x80Cu);
        v3 = *Source == 0;
        v32[0] = *((_DWORD *)Source + 1);
        if ( v3 )
        {
          strncpy_s((char *)&v32[1], 0x400u, Source + 12, strlen(Source + 12));
          v24 = Source + 1037;
          strncpy_s((char *)&v32[257], 0x400u, Source + 1036, strlen(Source + 1036));
          v32[513] = *((_DWORD *)Source + 515);
          v32[514] = 0;
          strncpy_s(Destination, 0x400u, Source + 12, strlen(Source + 12));
        }
        else
        {
          v32[514] = *((_DWORD *)Source + 2);
        }
        v4 = *(int (__thiscall ***)(_DWORD, int *))dword_1000B15C;
        v5 = v32;
        v6 = (int (__thiscall ***)(_DWORD, int *))dword_1000B15C;
        goto LABEL_59;
      }
      break;
    case 21:
      if ( Source && dword_1000B148 && *(_DWORD *)(dword_1000B148 + 12) )
      {
        memset(v32, 0, 0xA10u);
        if ( *Source )
        {
          v32[642] = (unsigned __int8)*Source;
        }
        else
        {
          v7 = *((_DWORD *)Source + 3);
          v32[0] = *((_DWORD *)Source + 2);
          v32[1] = v7;
          wcsncpy((wchar_t *)&v32[2], (const wchar_t *)Source + 8, 0x100u);
          strncpy_s((char *)&v32[130], 0x800u, Source + 528, 0x800u);
          v32[642] = 0;
        }
        v6 = *(int (__thiscall ****)(_DWORD, int *))(dword_1000B148 + 12);
        v5 = v32;
        goto LABEL_58;
      }
      break;
    case 23:
      if ( Source )
      {
        result = dword_1000B148;
        if ( dword_1000B148 )
        {
          v6 = *(int (__thiscall ****)(_DWORD, int *))(dword_1000B148 + 16);
          if ( v6 )
          {
            if ( *Source )
              v24 = (char *)-1;
            else
              v24 = (char *)*((_DWORD *)Source + 1);
            v5 = (int *)&v24;
            goto LABEL_58;
          }
        }
      }
      break;
    case 26:
      if ( Source )
      {
        result = dword_1000B148;
        if ( dword_1000B148 )
        {
          if ( *(_DWORD *)(dword_1000B148 + 20) )
          {
            memset(v32, 0, 0x810u);
            v8 = *((_DWORD *)Source + 2);
            v9 = *((_DWORD *)Source + 3);
            v32[0] = *(_DWORD *)Source;
            v32[2] = v8;
            v32[3] = v9;
            strncpy_s((char *)&v32[4], 0x800u, Source + 16, 0x800u);
            result = (***(int (__thiscall ****)(_DWORD, int *))(dword_1000B148 + 20))(
                       *(_DWORD *)(dword_1000B148 + 20),
                       v32);
          }
        }
      }
      break;
    case 27:
      if ( Source )
      {
        result = dword_1000B14C;
        if ( dword_1000B14C )
        {
          if ( *(_DWORD *)(dword_1000B14C + 8) )
          {
            memset(v31, 0, 0xC4u);
            *(_DWORD *)&v31[64] = *((_DWORD *)Source + 16);
            strncpy(v31, Source, 0x40u);
            strncpy(&v31[68], Source + 68, 0x80u);
            result = (***(int (__thiscall ****)(_DWORD, char *))(dword_1000B14C + 8))(
                       *(_DWORD *)(dword_1000B14C + 8),
                       v31);
          }
        }
      }
      break;
    case 29:
      v10 = 0;
      if ( Source )
      {
        result = dword_1000B14C;
        if ( dword_1000B14C )
        {
          if ( *(_DWORD *)(dword_1000B14C + 12) )
          {
            memset(v33, 0, 0x32CCu);
            v33[0] = 0;
            v11 = (char *)&v33[2];
            v24 = Source + 200;
            do
            {
              v12 = *(_DWORD *)&Source[4 * v10];
              if ( !v12 )
                break;
              *((_DWORD *)v11 - 1) = v12;
              strncpy(v11, v24, 0x100u);
              ++v33[0];
              v24 += 256;
              ++v10;
              v11 += 260;
            }
            while ( v10 < 50 );
            v6 = *(int (__thiscall ****)(_DWORD, int *))(dword_1000B14C + 12);
            v5 = v33;
            goto LABEL_58;
          }
        }
      }
      break;
    case 33:
      v13 = 0;
      if ( Source )
      {
        result = dword_1000B14C;
        if ( dword_1000B14C )
        {
          if ( *(_DWORD *)(dword_1000B14C + 16) )
          {
            memset(v33, 0, 0x3528u);
            v33[0] = 0;
            v14 = &v33[68];
            v24 = Source + 400;
            do
            {
              v15 = *(_DWORD *)&Source[8 * v13];
              if ( !*(_QWORD *)&Source[8 * v13] )
                break;
              *(v14 - 65) = *(_DWORD *)&Source[8 * v13 + 4];
              v16 = v24;
              *(v14 - 66) = v15;
              *(_BYTE *)v14 = Source[v13 + 13200];
              strncpy((char *)v14 - 256, v16, 0x100u);
              ++v33[0];
              v24 += 256;
              ++v13;
              v14 += 68;
            }
            while ( v13 < 50 );
            v6 = *(int (__thiscall ****)(_DWORD, int *))(dword_1000B14C + 16);
            v5 = v33;
            goto LABEL_58;
          }
        }
      }
      break;
    case 37:
      if ( Source )
      {
        result = dword_1000B14C;
        if ( dword_1000B14C )
        {
          if ( *(_DWORD *)(dword_1000B14C + 20) )
          {
            v25 = 0;
            *(_DWORD *)v26 = 0;
            v27 = 0;
            v28 = 0;
            v29 = 0;
            v30 = 0;
            v25 = *(_DWORD *)Source;
            strncpy(v26, Source + 4, 0x10u);
            v30 = *((_DWORD *)Source + 5);
            v6 = *(int (__thiscall ****)(_DWORD, int *))(dword_1000B14C + 20);
            v5 = &v25;
            goto LABEL_58;
          }
        }
      }
      break;
    case 40:
      if ( Source )
      {
        result = dword_1000B14C;
        if ( dword_1000B14C )
        {
          if ( *(_DWORD *)(dword_1000B14C + 24) )
          {
            memset(v31, 0, sizeof(v31));
            v17 = *((_DWORD *)Source + 33);
            *(_DWORD *)v31 = *(_DWORD *)Source;
            *(_DWORD *)&v31[132] = v17;
            strncpy(&v31[4], Source + 4, 0x80u);
            strncpy(&v31[136], Source + 136, 0x80u);
            strncpy(&v31[264], Source + 264, 0x80u);
            result = (***(int (__thiscall ****)(_DWORD, char *))(dword_1000B14C + 24))(
                       *(_DWORD *)(dword_1000B14C + 24),
                       v31);
          }
        }
      }
      break;
    case 42:
      if ( Source )
      {
        result = dword_1000B14C;
        if ( dword_1000B14C )
        {
          if ( *(_DWORD *)(dword_1000B14C + 28) )
          {
            memset(v32, 0, sizeof(v32));
            v18 = *((_DWORD *)Source + 2);
            v19 = *((_DWORD *)Source + 3);
            v32[0] = *(_DWORD *)Source;
            v20 = Source[16];
            v32[2] = v18;
            v21 = *((_DWORD *)Source + 5);
            LOBYTE(v32[4]) = v20;
            v32[5] = v21;
            v32[3] = v19;
            v32[10] = *((_DWORD *)Source + 10);
            strncpy((char *)&v32[6], Source + 24, 0x10u);
            v22 = (char *)&v32[43];
            v23 = Source + 1324;
            v24 = (char *)10;
            do
            {
              strncpy(v22 - 128, v23 - 1280, 0x80u);
              strncpy(v22, v23, 0x80u);
              v23 += 128;
              v22 += 256;
              --v24;
            }
            while ( v24 );
            v6 = *(int (__thiscall ****)(_DWORD, int *))(dword_1000B14C + 28);
            v5 = v32;
LABEL_58:
            v4 = *v6;
LABEL_59:
            result = (*v4)(v6, v5);
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}
// 1000B148: using guessed type int dword_1000B148;
// 1000B14C: using guessed type int dword_1000B14C;
// 1000B15C: using guessed type int dword_1000B15C;

//----- (10004D60) --------------------------------------------------------
char SGUPAPI_Init()
{
  void *v0; // esi
  _DWORD *v1; // eax
  void *v2; // ecx
  HMODULE v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  int v7; // ecx

  if ( !dword_1000B158 )
  {
    v0 = operator new(0x114u);
    if ( v0 )
      sub_100052C0((int)v0);
    else
      v0 = 0;
    dword_1000B158 = (int)v0;
  }
  if ( !dword_1000B140 )
  {
    v1 = operator new(8u);
    if ( v1 )
    {
      *v1 = &LauncherRelay::`vftable';
      v1[1] = 0;
    }
    else
    {
      v1 = 0;
    }
    v2 = *(void **)(*(_DWORD *)(dword_1000B158 + 268) + 1292);
    dword_1000B140 = (int)v1;
    if ( !sub_10001040(v2, (int)v1) )
      return 0;
    if ( (dword_1000B694 & 1) == 0 )
    {
      v4 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B694 |= 1u;
      SGUPLocalClient_Init = GetProcAddress(v4, "SGUPLocalClient_Init");
    }
    if ( !(unsigned __int8)SGUPLocalClient_Init() )
      return 0;
    sub_10001260();
  }
  v5 = (_DWORD *)dword_1000B144;
  if ( !dword_1000B144 )
  {
    v5 = operator new(8u);
    if ( v5 )
    {
      *v5 = &SGUPUserImpl::`vftable';
      v5[1] = 0;
    }
    else
    {
      v5 = 0;
    }
    dword_1000B144 = (int)v5;
  }
  v5[1] = dword_1000B158;
  v6 = (_DWORD *)dword_1000B148;
  if ( !dword_1000B148 )
  {
    v6 = operator new(0x18u);
    if ( v6 )
    {
      *v6 = &SGUPFriendsImpl::`vftable';
      v6[1] = 0;
      v6[2] = 0;
      v6[3] = 0;
      v6[4] = 0;
      v6[5] = 0;
    }
    else
    {
      v6 = 0;
    }
    dword_1000B148 = (int)v6;
  }
  v7 = dword_1000B158;
  v6[1] = dword_1000B140;
  v6[2] = v7;
  return 1;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007830: using guessed type void *LauncherRelay::`vftable';
// 100078D4: using guessed type void *SGUPFriendsImpl::`vftable';
// 10007A68: using guessed type void *SGUPUserImpl::`vftable';
// 1000B140: using guessed type int dword_1000B140;
// 1000B144: using guessed type int dword_1000B144;
// 1000B148: using guessed type int dword_1000B148;
// 1000B158: using guessed type int dword_1000B158;
// 1000B690: using guessed type int (*SGUPLocalClient_Init)(void);
// 1000B694: using guessed type int dword_1000B694;

//----- (10004E90) --------------------------------------------------------
int SGUPAPI_Term()
{
  _DWORD *v0; // esi
  HANDLE *v1; // edi
  const void *v2; // eax
  int result; // eax
  HMODULE v4; // eax
  void *v5; // [esp-4h] [ebp-Ch]
  void *v6; // [esp-4h] [ebp-Ch]
  void *v7; // [esp-4h] [ebp-Ch]

  if ( dword_1000B150 )
  {
    sub_10004FA0((void *)dword_1000B150);
    dword_1000B150 = 0;
  }
  if ( dword_1000B14C )
  {
    v5 = (void *)dword_1000B14C;
    *(_DWORD *)dword_1000B14C = &SGUPMatchMakingImpl::`vftable';
    operator delete(v5);
    dword_1000B14C = 0;
  }
  if ( dword_1000B148 )
  {
    v6 = (void *)dword_1000B148;
    *(_DWORD *)dword_1000B148 = &SGUPFriendsImpl::`vftable';
    operator delete(v6);
    dword_1000B148 = 0;
  }
  if ( dword_1000B144 )
  {
    v7 = (void *)dword_1000B144;
    *(_DWORD *)dword_1000B144 = &SGUPUserImpl::`vftable';
    operator delete(v7);
    dword_1000B144 = 0;
  }
  if ( dword_1000B158 )
  {
    v0 = (_DWORD *)(dword_1000B158 + 268);
    v1 = (HANDLE *)dword_1000B158;
    v2 = *(const void **)(dword_1000B158 + 268);
    if ( v2 )
    {
      UnmapViewOfFile(v2);
      *v0 = 0;
    }
    if ( *v1 )
      CloseHandle(*v1);
    operator delete(v1);
    dword_1000B158 = 0;
  }
  result = dword_1000B140;
  if ( dword_1000B140 )
  {
    if ( (dword_1000B68C & 1) == 0 )
    {
      v4 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B68C |= 1u;
      SGUPLocalClient_Term = GetProcAddress(v4, "SGUPLocalClient_Term");
    }
    result = SGUPLocalClient_Term();
    if ( dword_1000B140 )
      result = (**(int (__thiscall ***)(int, int))dword_1000B140)(dword_1000B140, 1);
    dword_1000B140 = 0;
  }
  return result;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 100078D4: using guessed type void *SGUPFriendsImpl::`vftable';
// 100078EC: using guessed type void *SGUPMatchMakingImpl::`vftable';
// 10007A68: using guessed type void *SGUPUserImpl::`vftable';
// 1000B140: using guessed type int dword_1000B140;
// 1000B144: using guessed type int dword_1000B144;
// 1000B148: using guessed type int dword_1000B148;
// 1000B14C: using guessed type int dword_1000B14C;
// 1000B150: using guessed type int dword_1000B150;
// 1000B158: using guessed type int dword_1000B158;
// 1000B688: using guessed type int (*SGUPLocalClient_Term)(void);
// 1000B68C: using guessed type int dword_1000B68C;

//----- (10004FA0) --------------------------------------------------------
void *__stdcall sub_10004FA0(void *a1)
{
  void (__thiscall ***v1)(_DWORD, int); // ecx
  void *v2; // eax

  *(_DWORD *)a1 = &SGUPPeerToPeerImpl::`vftable';
  v1 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)a1 + 3);
  if ( v1 )
    (**v1)(v1, 1);
  v2 = (void *)*((_DWORD *)a1 + 2);
  *((_DWORD *)a1 + 3) = 0;
  if ( v2 )
    operator delete(v2);
  *((_DWORD *)a1 + 2) = 0;
  if ( *((_DWORD *)a1 + 12) >= 0x10u )
    operator delete(*((void **)a1 + 7));
  *((_DWORD *)a1 + 12) = 15;
  *((_DWORD *)a1 + 11) = 0;
  *((_BYTE *)a1 + 28) = 0;
  operator delete(a1);
  return a1;
}
// 1000714C: using guessed type void __cdecl operator delete(void *);
// 10007A4C: using guessed type void *SGUPPeerToPeerImpl::`vftable';

//----- (10005040) --------------------------------------------------------
int SGUPAPI_GetAuthToken()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B140;
  if ( dword_1000B140 )
  {
    if ( (dword_1000B674 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B674 |= 1u;
      SGUPLocalClient_GetAuthToken = GetProcAddress(v1, "SGUPLocalClient_GetAuthToken");
    }
    result = SGUPLocalClient_GetAuthToken();
  }
  return result;
}
// 1000B140: using guessed type int dword_1000B140;
// 1000B670: using guessed type int (*SGUPLocalClient_GetAuthToken)(void);
// 1000B674: using guessed type int dword_1000B674;

//----- (10005080) --------------------------------------------------------
int SGUPAPI_RenewAuthToken()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B140;
  if ( dword_1000B140 )
  {
    if ( (dword_1000B66C & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B66C |= 1u;
      SGUPLocalClient_RenewAuthToken = GetProcAddress(v1, "SGUPLocalClient_RenewAuthToken");
    }
    result = SGUPLocalClient_RenewAuthToken();
  }
  return result;
}
// 1000B140: using guessed type int dword_1000B140;
// 1000B668: using guessed type int (*SGUPLocalClient_RenewAuthToken)(void);
// 1000B66C: using guessed type int dword_1000B66C;

//----- (100050C0) --------------------------------------------------------
char *SGUPAPI_GetCurrentAccessToken()
{
  return Destination;
}

//----- (100050D0) --------------------------------------------------------
int SGUPAPI_GetMessengerAuthToken()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B140;
  if ( dword_1000B140 )
  {
    if ( (dword_1000B664 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B664 |= 1u;
      SGUPLocalClient_GetMessengerAuthToken = GetProcAddress(v1, "SGUPLocalClient_GetMessengerAuthToken");
    }
    result = SGUPLocalClient_GetMessengerAuthToken();
  }
  return result;
}
// 1000B140: using guessed type int dword_1000B140;
// 1000B660: using guessed type int (*SGUPLocalClient_GetMessengerAuthToken)(void);
// 1000B664: using guessed type int dword_1000B664;

//----- (10005110) --------------------------------------------------------
int SGUPAPI_RenewMessengerAuthToken()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B140;
  if ( dword_1000B140 )
  {
    if ( (dword_1000B65C & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B65C |= 1u;
      SGUPLocalCleint_RenewMessengerAuthToken = GetProcAddress(v1, "SGUPLocalCleint_RenewMessengerAuthToken");
    }
    result = SGUPLocalCleint_RenewMessengerAuthToken();
  }
  return result;
}
// 1000B140: using guessed type int dword_1000B140;
// 1000B658: using guessed type int (*SGUPLocalCleint_RenewMessengerAuthToken)(void);
// 1000B65C: using guessed type int dword_1000B65C;

//----- (10005150) --------------------------------------------------------
_DWORD *__cdecl SGUPAPI_SetCallback(int a1)
{
  int v1; // edx
  int v2; // edx
  _DWORD *result; // eax
  int v4; // edx

  result = (_DWORD *)a1;
  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 4);
    switch ( v4 )
    {
      case 1:
        dword_1000B15C = a1;
        break;
      case 100:
        if ( dword_1000B148 )
          *(_DWORD *)(dword_1000B148 + 12) = a1;
        break;
      case 101:
        if ( dword_1000B148 )
          *(_DWORD *)(dword_1000B148 + 16) = a1;
        break;
      case 102:
        if ( dword_1000B148 )
          *(_DWORD *)(dword_1000B148 + 20) = a1;
        break;
      case 200:
      case 201:
      case 202:
      case 203:
      case 204:
      case 205:
        if ( dword_1000B14C )
        {
          v1 = *(_DWORD *)(a1 + 4);
          switch ( v1 )
          {
            case 201:
              *(_DWORD *)(dword_1000B14C + 12) = a1;
              break;
            case 202:
              *(_DWORD *)(dword_1000B14C + 16) = a1;
              break;
            case 203:
              *(_DWORD *)(dword_1000B14C + 20) = a1;
              break;
            case 200:
              *(_DWORD *)(dword_1000B14C + 8) = a1;
              break;
            case 204:
              *(_DWORD *)(dword_1000B14C + 24) = a1;
              break;
            case 205:
              *(_DWORD *)(dword_1000B14C + 28) = a1;
              break;
          }
        }
        break;
      case 300:
      case 301:
      case 302:
      case 303:
        if ( dword_1000B150 )
        {
          result = *(_DWORD **)(dword_1000B150 + 12);
          if ( result )
          {
            v2 = *(_DWORD *)(a1 + 4);
            switch ( v2 )
            {
              case 300:
                result[1] = a1;
                break;
              case 301:
                result[2] = a1;
                break;
              case 302:
                result[3] = a1;
                break;
              case 303:
                result[4] = a1;
                break;
            }
          }
        }
        break;
    }
  }
  return result;
}
// 10001FC8: conditional instruction was optimized away because of '%arg_0.4!=0'
// 100024CE: conditional instruction was optimized away because of 'ecx.4!=0'
// 1000B148: using guessed type int dword_1000B148;
// 1000B14C: using guessed type int dword_1000B14C;
// 1000B150: using guessed type int dword_1000B150;
// 1000B15C: using guessed type int dword_1000B15C;

//----- (10005230) --------------------------------------------------------
int SGUPAPI_RunCallback()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B140;
  if ( dword_1000B140 )
  {
    if ( (dword_1000B684 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B140 + 4);
      dword_1000B684 |= 1u;
      SGUPLocalClient_RunCallback = GetProcAddress(v1, "SGUPLocalClient_RunCallback");
    }
    result = SGUPLocalClient_RunCallback();
  }
  return result;
}
// 1000B140: using guessed type int dword_1000B140;
// 1000B680: using guessed type int (*SGUPLocalClient_RunCallback)(void);
// 1000B684: using guessed type int dword_1000B684;

//----- (10005270) --------------------------------------------------------
int SGUPUser()
{
  return dword_1000B144;
}
// 1000B144: using guessed type int dword_1000B144;

//----- (10005280) --------------------------------------------------------
int SGUPFriends()
{
  return dword_1000B148;
}
// 1000B148: using guessed type int dword_1000B148;

//----- (10005290) --------------------------------------------------------
int SGUPMatchMaking()
{
  return dword_1000B14C;
}
// 1000B14C: using guessed type int dword_1000B14C;

//----- (100052A0) --------------------------------------------------------
int SGUPPeerToPeer()
{
  return dword_1000B150;
}
// 1000B150: using guessed type int dword_1000B150;

//----- (100052B0) --------------------------------------------------------
int SGUPOverlay()
{
  return dword_1000B154;
}
// 1000B154: using guessed type int dword_1000B154;

//----- (100052C0) --------------------------------------------------------
int __usercall sub_100052C0@<eax>(int a1@<esi>)
{
  HANDLE v1; // eax
  int result; // eax
  LPVOID v3; // eax

  *(_DWORD *)(a1 + 264) = 0;
  v1 = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, 0x510u, "SGUPSharedUserData");
  *(_DWORD *)a1 = v1;
  if ( v1 )
  {
    SetNamedSecurityInfoA((LPSTR)"SGUPSharedUserData", SE_KERNEL_OBJECT, 4u, 0, 0, 0, 0);
    *(_DWORD *)(a1 + 264) = 1296;
    strncpy_s((char *)(a1 + 4), 0x104u, "SGUPSharedUserData", 0x103u);
    v3 = MapViewOfFile(*(HANDLE *)a1, 6u, 0, 0, 0);
    *(_DWORD *)(a1 + 268) = v3;
    if ( v3 )
    {
      result = 1;
    }
    else
    {
      CloseHandle(*(HANDLE *)a1);
      result = 0;
    }
  }
  else
  {
    GetLastError();
    result = 0;
  }
  return result;
}

//----- (10005360) --------------------------------------------------------
bool SGUPIAPI_MessengerInit()
{
  _DWORD *v0; // eax
  int v1; // eax
  void *v2; // esi
  bool result; // al

  if ( !dword_1000B560 )
  {
    v0 = operator new(8u);
    if ( v0 )
    {
      *v0 = &LauncherRelay::`vftable';
      v0[1] = 0;
    }
    else
    {
      v0 = 0;
    }
    dword_1000B560 = (int)v0;
  }
  v1 = dword_1000B564;
  if ( !dword_1000B564 )
  {
    v2 = operator new(0x114u);
    if ( v2 )
    {
      sub_100052C0((int)v2);
      v1 = (int)v2;
    }
    else
    {
      v1 = 0;
    }
    dword_1000B564 = v1;
  }
  result = sub_10001040(*(void **)(*(_DWORD *)(v1 + 268) + 1292), dword_1000B560);
  if ( result )
  {
    if ( (dword_1000B5CC & 1) == 0 )
    {
      dword_1000B5CC |= 1u;
      SGUPLocalClient_MessengerInit = GetProcAddress(*(HMODULE *)(dword_1000B560 + 4), "SGUPLocalClient_MessengerInit");
    }
    result = (unsigned __int8)SGUPLocalClient_MessengerInit() != 0;
  }
  return result;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007830: using guessed type void *LauncherRelay::`vftable';
// 1000B560: using guessed type int dword_1000B560;
// 1000B564: using guessed type int dword_1000B564;
// 1000B5C8: using guessed type int (*SGUPLocalClient_MessengerInit)(void);
// 1000B5CC: using guessed type int dword_1000B5CC;

//----- (10005420) --------------------------------------------------------
int SGUPIAPI_MessengerTerm()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B5C4 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B5C4 |= 1u;
      SGUPLocalClient_MessengerTerm = GetProcAddress(v1, "SGUPLocalClient_MessengerTerm");
    }
    result = SGUPLocalClient_MessengerTerm();
    if ( dword_1000B560 )
      result = (**(int (__thiscall ***)(int, int))dword_1000B560)(dword_1000B560, 1);
    dword_1000B560 = 0;
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B5C0: using guessed type int (*SGUPLocalClient_MessengerTerm)(void);
// 1000B5C4: using guessed type int dword_1000B5C4;

//----- (10005470) --------------------------------------------------------
int SGUPIAPI_SendDuplicateLoginEvent()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B5BC & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B5BC |= 1u;
      SGUPLocalClient_SendDuplicateLoginEvent = GetProcAddress(v1, "SGUPLocalClient_SendDuplicateLoginEvent");
    }
    result = SGUPLocalClient_SendDuplicateLoginEvent();
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B5B8: using guessed type int (*SGUPLocalClient_SendDuplicateLoginEvent)(void);
// 1000B5BC: using guessed type int dword_1000B5BC;

//----- (100054B0) --------------------------------------------------------
int SGUPIAPI_GetMemberInfo()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B5B4 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B5B4 |= 1u;
      SGUPLocalClient_GetMemberInfo = GetProcAddress(v1, "SGUPLocalClient_GetMemberInfo");
    }
    result = SGUPLocalClient_GetMemberInfo();
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B5B0: using guessed type int (*SGUPLocalClient_GetMemberInfo)(void);
// 1000B5B4: using guessed type int dword_1000B5B4;

//----- (100054F0) --------------------------------------------------------
int SGUPIAPI_InternalRenewAuthToken()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B5AC & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B5AC |= 1u;
      SGUPLocalClient_InternalRenewAuthToken = GetProcAddress(v1, "SGUPLocalClient_InternalRenewAuthToken");
    }
    result = SGUPLocalClient_InternalRenewAuthToken();
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B5A8: using guessed type int (*SGUPLocalClient_InternalRenewAuthToken)(void);
// 1000B5AC: using guessed type int dword_1000B5AC;

//----- (10005530) --------------------------------------------------------
void __cdecl SGUPIAPI_SetCallback(int a1)
{
  int v1; // eax

  if ( dword_1000B560 && a1 )
  {
    v1 = *(_DWORD *)(a1 + 4);
    switch ( v1 )
    {
      case 2:
        sub_100012A0(a1);
        break;
      case 3:
        sub_100012E0(a1);
        break;
      case 6:
        sub_10001320(a1);
        break;
      case 7:
        sub_10001360(a1);
        break;
      case 8:
        sub_100013A0(a1);
        break;
    }
  }
}
// 1000B560: using guessed type int dword_1000B560;

//----- (10005590) --------------------------------------------------------
int __cdecl SGUPIAPI_SetCallbackSubscriptReq(int a1)
{
  int result; // eax
  HMODULE v2; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B5A4 & 1) == 0 )
    {
      v2 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B5A4 |= 1u;
      SGUPLocalClient_SetCallbackSubscriptReq = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                           v2,
                                                                           "SGUPLocalClient_SetCallbackSubscriptReq");
    }
    result = SGUPLocalClient_SetCallbackSubscriptReq(a1);
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B5A0: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackSubscriptReq)(_DWORD);
// 1000B5A4: using guessed type int dword_1000B5A4;

//----- (100055D0) --------------------------------------------------------
int __cdecl SGUPIAPI_SetCallbackMessengerConfigUpdate(int a1)
{
  int result; // eax
  HMODULE v2; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B59C & 1) == 0 )
    {
      v2 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B59C |= 1u;
      SGUPLocalClient_SetCallbackMessengerConfigUpdate = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                                    v2,
                                                                                    "SGUPLocalClient_SetCallbackMessengerConfigUpdate");
    }
    result = SGUPLocalClient_SetCallbackMessengerConfigUpdate(a1);
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B598: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackMessengerConfigUpdate)(_DWORD);
// 1000B59C: using guessed type int dword_1000B59C;

//----- (10005610) --------------------------------------------------------
int __cdecl SGUPIAPI_SetCallbackGetMemberInfo(int a1)
{
  int result; // eax
  HMODULE v2; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B594 & 1) == 0 )
    {
      v2 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B594 |= 1u;
      SGUPLocalClient_SetCallbackGetMemberInfo = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                            v2,
                                                                            "SGUPLocalClient_SetCallbackGetMemberInfo");
    }
    result = SGUPLocalClient_SetCallbackGetMemberInfo(a1);
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B590: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackGetMemberInfo)(_DWORD);
// 1000B594: using guessed type int dword_1000B594;

//----- (10005650) --------------------------------------------------------
int __cdecl SGUPIAPI_SetCallbackInternalRenewAuthToken(int a1)
{
  int result; // eax
  HMODULE v2; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B58C & 1) == 0 )
    {
      v2 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B58C |= 1u;
      SGUPLocalClient_SetCallbackInternalRenewAuthToken = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                                     v2,
                                                                                     "SGUPLocalClient_SetCallbackInternalRenewAuthToken");
    }
    result = SGUPLocalClient_SetCallbackInternalRenewAuthToken(a1);
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B588: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackInternalRenewAuthToken)(_DWORD);
// 1000B58C: using guessed type int dword_1000B58C;

//----- (10005690) --------------------------------------------------------
int __cdecl SGUPIAPI_SetCallbackDuplicateLoginResult(int a1)
{
  int result; // eax
  HMODULE v2; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B584 & 1) == 0 )
    {
      v2 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B584 |= 1u;
      SGUPLocalClient_SetCallbackDuplicateLoginResult = (int (__cdecl *)(_DWORD))GetProcAddress(
                                                                                   v2,
                                                                                   "SGUPLocalClient_SetCallbackDuplicateLoginResult");
    }
    result = SGUPLocalClient_SetCallbackDuplicateLoginResult(a1);
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B580: using guessed type int (__cdecl *SGUPLocalClient_SetCallbackDuplicateLoginResult)(_DWORD);
// 1000B584: using guessed type int dword_1000B584;

//----- (100056D0) --------------------------------------------------------
bool SGUPIAPI_OverlayHostInit()
{
  _DWORD *v0; // eax
  int v1; // eax
  void *v2; // esi
  bool result; // al

  if ( !dword_1000B560 )
  {
    v0 = operator new(8u);
    if ( v0 )
    {
      *v0 = &LauncherRelay::`vftable';
      v0[1] = 0;
    }
    else
    {
      v0 = 0;
    }
    dword_1000B560 = (int)v0;
  }
  v1 = dword_1000B564;
  if ( !dword_1000B564 )
  {
    v2 = operator new(0x114u);
    if ( v2 )
    {
      sub_100052C0((int)v2);
      v1 = (int)v2;
    }
    else
    {
      v1 = 0;
    }
    dword_1000B564 = v1;
  }
  result = sub_10001040(*(void **)(*(_DWORD *)(v1 + 268) + 1292), dword_1000B560);
  if ( result )
  {
    if ( (dword_1000B57C & 1) == 0 )
    {
      dword_1000B57C |= 1u;
      SGUPLocalClient_OverlayHostInit = GetProcAddress(
                                          *(HMODULE *)(dword_1000B560 + 4),
                                          "SGUPLocalClient_OverlayHostInit");
    }
    result = (unsigned __int8)SGUPLocalClient_OverlayHostInit() != 0;
  }
  return result;
}
// 1000712C: using guessed type void *__cdecl operator new(unsigned int);
// 10007830: using guessed type void *LauncherRelay::`vftable';
// 1000B560: using guessed type int dword_1000B560;
// 1000B564: using guessed type int dword_1000B564;
// 1000B578: using guessed type int (*SGUPLocalClient_OverlayHostInit)(void);
// 1000B57C: using guessed type int dword_1000B57C;

//----- (10005790) --------------------------------------------------------
int SGUPIAPI_OverlayHostTerm()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B574 & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B574 |= 1u;
      SGUPLocalClient_OverlayHostTerm = GetProcAddress(v1, "SGUPLocalClient_OverlayHostTerm");
    }
    result = SGUPLocalClient_OverlayHostTerm();
    if ( dword_1000B560 )
      result = (**(int (__thiscall ***)(int, int))dword_1000B560)(dword_1000B560, 1);
    dword_1000B560 = 0;
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B570: using guessed type int (*SGUPLocalClient_OverlayHostTerm)(void);
// 1000B574: using guessed type int dword_1000B574;

//----- (100057E0) --------------------------------------------------------
int SGUPIAPI_SetCallbackUpdateAuthToken()
{
  int result; // eax
  HMODULE v1; // eax

  result = dword_1000B560;
  if ( dword_1000B560 )
  {
    if ( (dword_1000B56C & 1) == 0 )
    {
      v1 = *(HMODULE *)(dword_1000B560 + 4);
      dword_1000B56C |= 1u;
      SGUPLocalClient_SetCallbackUpdateAuthToken = GetProcAddress(v1, "SGUPLocalClient_SetCallbackUpdateAuthToken");
    }
    result = SGUPLocalClient_SetCallbackUpdateAuthToken();
  }
  return result;
}
// 1000B560: using guessed type int dword_1000B560;
// 1000B568: using guessed type int (*SGUPLocalClient_SetCallbackUpdateAuthToken)(void);
// 1000B56C: using guessed type int dword_1000B56C;

//----- (10005DE2) --------------------------------------------------------
int sub_10005DE2()
{
  return _clean_type_info_names_internal(&unk_1000B12C);
}
// 1000619C: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (10005EA6) --------------------------------------------------------
void *sub_10005EA6()
{
  return &unk_1000821C;
}

// nfuncs=169 queued=117 decompiled=117 lumina nreq=0 worse=0 better=0
// ALL OK, 117 function(s) have been successfully decompiled
